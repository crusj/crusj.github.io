<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[redis笔记]]></title>
    <url>%2F2020%2F04%2F06%2Fredis%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[redis常见知识点整理 redis基本数据类型string set key value、set will replace the exists key、max value 512M，set key value nx,设置key,且key不存在,set key value xx设置key,且key存在 get key 自增incr key,自增定义步长incrby key step 自减decr key,自减定义步长decrby key step INCR is atomic， never race condition 设置多个值mset key1 value key2 value 获取多个值mget key1 key2 判断值是否存在exists key，return 1|0 删除值del key 值类型type key 设置过期时间 set key value ex second、expire key second 查看剩余存活时间ttl key hash 设置单个值hset key field value 设置多个值hmset key field value field value 获取单个值hget key field 获取多个值 hmget key field1 field2 field是否存在hexists key field 获取所有 hgetall key 获取所有fieldhkeys key 获取field数量hlen key 删除值hdel key field1 [field2] 自增hincrby key field step list Redis lists are implemented via Linked Lists 左边插入lpush key value,多值插入lpush key value1 value2 右边插入rpush key value,多值插入rpush key value1 value2 根据index获取值 lindex key index 范围查找lrange start end start从0开始,end为-1代表最后一个元素，-2代表倒数第二个元素 pop element lpop key 、rpop key 列表长度llen key 根据index设置值lset key index value 可以通过lpush的方式来保存一些最新的信息，提高访问速度 修剪长度ltrim key start end pop阻塞brpop key timeout、blpop key timeout， use 0 as timeout is forever 删除列表 del key set 集合其实就是一个value为null的hash表 设置集合sadd key value [value...] 查看集合smember key 是否集合成员sismember key value 获取集合成员数scard key 集合差集sdiff key1 key2 集合交集sinter key1 key2 返回多个集合的并集sunion key1 [key2] 移除集合中的一个随机成员spop key 获取集合中一个或多个集合成员srandmember key [count] 移除集合中一个或多个成员srem key member1 [member2] sort set 相比集合多了一个score,指向集合的值 redis-server 启动指定配置配件redis-server ./redis.conf&amp; redis-cli操作 查看配置信息config get [pattern],例如查看dir目录config get dir、查看所有配置config get * 查看某个keykeys [pattren],查看所有keyskeys * 保存数据到磁盘,bgsave会fork一个子进程后台保存数据到磁盘、save直接保存 查看主从信息,info replication redis主从原理每次slave发送sync命令到master,master运行bgsave保存数据到文件,并记录这段时间的命令，然后把文件和命令发送给slave,slave抛弃以前数据进行恢复,这是slave只能读 主服务器设置权限验证masterauth 123456 从服务器 redis slave slaveof ip port, 如果master设置了权限masterauth 123456 数据备份AOF简介将每条命令写到文件，redis启动时执行这些命令,默认关闭,如果开启redis会优先加载aof文件 配置appendonly yes appendfsync always|eversec|no always,每个命令立即保存eversec,每秒保存no,操作系统自己控制 缺点文件臃肿,恢复效率慢 优点数据持久化更安全 RDB快照简介保存某个时间节点的快早 配置save &lt;second&gt; &lt;changes&gt; 每过多少秒至少有多少个改动则保存快照 缺点一段时间内丢失 优点数据精简，恢复快 redis数据淘汰机制内存设置maxmemory 100mb 淘汰策略maxmemory-policy noeviction noeviction:默认策略，不淘汰，如果内存已满，添加数据是报错。 allkeys-lru:在所有键中，选取最近最少使用的数据抛弃。 volatile-lru:在设置了过期时间的所有键中，选取最近最少使用的数据抛弃。 allkeys-random: 在所有键中，随机抛弃。 volatile-random: 在设置了过期时间的所有键，随机抛弃。 volatile-ttl:在设置了过期时间的所有键，抛弃存活时间最短的数据。 一些场景redis实现锁1）SETNX命令（SET if Not eXists） 语法：SETNX key value 功能：当且仅当 key 不存在，将 key 的值设为 value ，并返回1；若给定的 key 已经存在，则 SETNX 不做任何动作，并返回0。 2）expire命令 语法：expire KEY seconds 功能：设置key的过期时间。如果key已过期，将会被自动删除。 3）DEL命令 语法：DEL key [KEY …] 功能：删除给定的一个或多个 key ,不存在的 key 会被忽略 利用set查重利用list实现队列]]></content>
      <categories>
        <category>redis笔记</category>
      </categories>
      <tags>
        <tag>redis 面试</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[三角形最小路径和]]></title>
    <url>%2F2020%2F04%2F06%2F%E4%B8%89%E8%A7%92%E5%BD%A2%E6%9C%80%E5%B0%8F%E8%B7%AF%E5%BE%84%E5%92%8C%2F</url>
    <content type="text"><![CDATA[经典动态规划：三角形最小路径和 题目给定一个三角形，找出自顶向下的最小路径和。每一步只能移动到下一行中相邻的结点上。 例如，给定三角形： [ [2], [3,4], [6,5,7], [4,1,8,3] ] 自顶向下的最小路径和为 11（即，2 + 3 + 5 + 1 = 11）。 思路最优子结构从上至下每个点的最小路径和为当前点+min(相邻行左点最小路径和,相邻行右点的最小路径和) 状态变化行数n的变化,以及当前行点索引的变化 状态转移方程 dp(n,index) = a[n-1][index] + min(dp(n+1,index), dp(n+1,index+1)) base问题n = 层数，最小值为当前行索引值 重叠子问题某行某个点的最小路径和 php版本class Solution { private $table=[]; private $floor = 0; /** * @param Integer[][] $triangle * @return Integer */ function minimumTotal($triangle) { $this->floor = count($triangle); //从第一层,索引为0开始 return $this->minimumTotal2($triangle,1,0); } /** * n层数，index层索引 **/ function minimumTotal2(&amp;$triangle,$n,$index): int{ if($n == $this->floor){ return $triangle[$n-1][$index]; } //重叠子问题 if(isset($this->table[$n+1][$index])){ $a = $this->table[$n+1][$index]; }else{ $a = $this->minimumTotal2($triangle,$n+1,$index); $this->table[$n+1][$index] = $a; } if(isset($this->table[$n+1][$index + 1])){ $b = $this->table[$n+1][$index + 1]; }else{ $b = $this->minimumTotal2($triangle,$n+1,$index + 1); $this->table[$n+1][$index + 1] = $b; } $min = $a > $b ? $b: $a; //当前行点加上最小值 $ret = $triangle[$n-1][$index] + $min; return $ret; } } //最优子结构 //从上至下每个点的最小路径和为当前点+min(相邻行左点最小路径和,相邻行右点的最小路径和) //状态变化 //行数n的变化,以及当前行点索引的变化 //状态转移方程 // dp(n,index) = a[n-1][index] + min(dp(n+1,index), dp(n+1,index+1)) //base问题 //n = 层数，最小值为当前行索引值 //重叠子问题 //某行某个点的最小路径和 golang版本func minimumTotal(triangle [][]int) int { dp := make([][]int, len(triangle)) for i,_ := range triangle { dp[i] = make([]int,len(triangle[i])) } triangleIndex := make([]int,len(triangle)) triangleIndexLen := len(triangle) for i,v := range triangle { triangleIndex[i] = len(v) } return Step(0, 0, triangle,triangleIndex,&amp;triangleIndexLen, dp) } func Step(row int, col int, triangle [][]int,triangleIndex []int,triangleIndexLen *int, dp [][]int) int { if *triangleIndexLen == row || triangleIndex[row] == col { return 0 } if dp[row][col] != 0 { return dp[row][col] } a := Step(row+1, col, triangle,triangleIndex,triangleIndexLen,dp) b := Step(row+1, col+1, triangle,triangleIndex,triangleIndexLen, dp) if a > b { dp[row][col] = b + triangle[row][col] }else{ dp[row][col] = a + triangle[row][col] } return dp[row][col] }]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>动态规划</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[打家劫舍]]></title>
    <url>%2F2020%2F04%2F06%2F%E6%89%93%E5%AE%B6%E5%8A%AB%E8%88%8D%2F</url>
    <content type="text"><![CDATA[经典动态规划：打家劫舍 题目你是一个专业的小偷，计划偷窃沿街的房屋。每间房内都藏有一定的现金，影响你偷窃的唯一制约因素就是相邻的房屋装有相互连通的防盗系统，如果两间相邻的房屋在同一晚上被小偷闯入，系统会自动报警。 给定一个代表每个房屋存放金额的非负整数数组，计算你在不触动警报装置的情况下，能够偷窃到的最高金额。 示例 1: 输入: [1,2,3,1]输出: 4解释: 偷窃 1 号房屋 (金额 = 1) ，然后偷窃 3 号房屋 (金额 = 3)。 偷窃到的最高金额 = 1 + 3 = 4 。示例 2: 输入: [2,7,9,3,1]输出: 12解释: 偷窃 1 号房屋 (金额 = 2), 偷窃 3 号房屋 (金额 = 9)，接着偷窃 5 号房屋 (金额 = 1)。 偷窃到的最高金额 = 2 + 9 + 1 = 12 思路第n间房子要么偷，要么不偷如果偷第n间房子，最大金额=第n间房子金额+第n-2间房子以前所有房子的最大金额如果不偷第n间房子，最大金额=n-1间房子以前能偷房子的最大金额 最优子结构： 非相邻房子金额的最大值状态变化： 房子的数量状态转移方程： dp(n) = max(a[n-1] + dp(n-2), dp(n-1)) n&gt;=0base条件： n=0为0，n=1为a[0]重叠子问题： 需要前n间房能偷得最大金额表 php版本class Solution { private $table = []; /** * @param Integer[] $nums * @return Integer */ function rob($nums) { return $this->steal($nums,count($nums)); } function steal(&amp;$nums,$n): int{ if($n == 0){ return 0; }elseif($n == 1){ return $nums[0]; } //重叠子问题 if(isset($this->table[$n])){ $max = $this->table[$n]; }else{ $max = $nums[$n-1] + $this->steal($nums,$n-2); $this->table[$n] = $max; } if(isset($this->table[$n-1])){ $max2 = $this->table[$n-1]; }else{ $max2 = $this->steal($nums, $n-1); $this->table[$n-1] = $max2; } return $max > $max2 ? $max: $max2; } } golang版本var table map[int]int func rob(nums []int) int { table = make(map[int]int) return steal(nums,len(nums)) } func steal(nums []int, n int) int{ if n == 0 { return 0 } if n == 1 { return nums[0] } var max1,max2 int if v,exist := table[n];exist { max1 = v }else{ max1 = nums[n-1] + steal(nums,n-2) table[n] = max1 } if v,exist := table[n-1];exist { max2 = v }else{ max2 = steal(nums,n-1) table[n-1] = max2 } if max1 &lt; max2 { return max2 }else{ return max1 } }]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>动态规划</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[golang函数参数传值，传指针以及传引用]]></title>
    <url>%2F2020%2F04%2F05%2Fgolang%E5%87%BD%E6%95%B0%E5%8F%82%E6%95%B0%E4%BC%A0%E5%80%BC%EF%BC%8C%E4%BC%A0%E6%8C%87%E9%92%88%E4%BB%A5%E5%8F%8A%E4%BC%A0%E5%BC%95%E7%94%A8%2F</url>
    <content type="text"><![CDATA[golang函数参数传值，传指针以及传引用区别 三种参数传递方式的区别传值函数参数传值，会栈中创建传递变量的副本，对此副本的任何操作都不会影响被传递变量本身 传指针指针是一种特殊变量,指针变量存的值是指向变量的地址,对指针的操作都会影响到被传递指针变量指向的值,改变指针指向(值),并不影响原指向 传引用引用与指针不同,指针的值为指向变量地址,c++中传引用相当于符号表中的别名,因此对应用变量的操作会直接作用于被传递变量 示例传值func main() { a := 1 fmt.Printf("变量a的值为%v\n",a) fmt.Printf("变量a的地址为:%p\n",&amp;a) increment(a) fmt.Printf("传参后变量a的值为%v\n",a) } func increment(b int){ fmt.Printf("函数内变量b的地址为:%p\n",&amp;b) b ++ } //结果,参数b变量的地址是与a变量不同,为a变量的副本 变量a的值为1 变量a的地址为:0xc0000160a8 函数内变量b的地址为:0xc0000160c8 传参后变量a的值为1 传指针func main() { a := 1 b := &amp;a fmt.Printf("变量a的值为%v\n",a) fmt.Printf("变量a的地址为%p\n",&amp;a) fmt.Printf("指针b指向地址为:%v\n",b) fmt.Printf("指针b地址为:%p\n",&amp;b) increment(b) fmt.Printf("传参后变量a的值为%v\n",a) fmt.Printf("传参后指针b的值为%p\n",b) } func increment(b *int){ fmt.Printf("函数内指针b的指向为:%p\n",b) fmt.Printf("函数内指针b的地址为:%p\n",&amp;b) *b ++ fmt.Printf("函数内*b的地址为:%p\n",&amp;(*b)) b = nil } //结果,在函数中指针b的地址与传入指针b的地址不同，但都指向变量a的地址，表示函数传指针会在栈中对参数指针创建一个指向相同地址的副本,所以在最后把b指向nil后，原传入的指针依旧不变 变量a的值为1 变量a的地址为0xc00008e010 指针b指向地址为:0xc00008e010 指针b地址为:0xc000098018 函数内指针b的指向为:0xc00008e010 函数内指针b的地址为:0xc000098028 函数内*b的地址为:0xc00008e010 传参后变量a的值为2 传参后指针b的值为0xc00008e010 传引用golang不存在传引用,php存在,但php的引用不同于c++是符号表别名,php引用是多个名字指向同一个变量 $a = 1; function increment(&amp;$a){ $a ++; } function delete(&amp;$a){ unset($a); } echo "变量a值为".$a."\n"; increment($a); echo "传引用变量a值为".$a."\n"; delete($a); echo "函数内删除变量a,a值为".$a."\n"; //结果,php函数内unset($a),只是切断了对变量a的绑定,所以被传参$a仍旧存在 变量a值为1 传引用变量a值为2 函数内删除变量a,a值为2 总结golang函数参数不存在传引用，函数参数传值和传指针都会在函数体内创建,对应变量或指针变量的副本,对函数内传递指针变量而言，只会修改其指向变量的值，如果改变指针变量指向，并不会影响被传入指针的指向]]></content>
      <categories>
        <category>golang</category>
      </categories>
      <tags>
        <tag>golang</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[php文件锁或redis实现高并发秒杀]]></title>
    <url>%2F2020%2F04%2F05%2Fphp%E6%96%87%E4%BB%B6%E9%94%81%E6%88%96redis%E5%AE%9E%E7%8E%B0%E9%AB%98%E5%B9%B6%E5%8F%91%E7%A7%92%E6%9D%80%2F</url>
    <content type="text"><![CDATA[php文件锁或redis实现高并发秒杀 工具 redis,redis-cli php7以及redis扩展,swoole扩展 并发测试工具ab(ApacheBench) 场景某型号笔记本电脑限卖10台,进行秒杀 应用php文件锁实现$http = new swoole_http_server("0.0.0.0", 9999); $max = 10; $http->on('request', function (swoole_http_request $request, swoole_http_response $response){ //随机数模拟用户ID $userId = rand(1, 10000); $resource = fopen(__DIR__.'/lock','w+'); if(flock($resource,LOCK_EX)){//排它锁 $redisInstance = new Redis(); $redisInstance->connect('127.0.0.1',6379); if(intval($redisInstance->llen('usersId')) >= 10){ echo "秒杀已结束\n"; }else{ $redisInstance->lpush('usersId',$userId); } flock($resource,LOCK_UN);//解锁 $redisInstance->close(); } fclose($resource); }); $http->start(); 截图 截图中,列表usersId长度为10与秒杀限卖数量相同 redis实现利用redis操作的原子性也可以达到同样的效果,本例中使用自减的方式,也可以使用自增或者预先存放秒杀数量的list,然后进行lpop的方式 $http = new swoole_http_server("0.0.0.0", 9999); $redisInstance = new Redis(); $redisInstance->connect('127.0.0.1','6379'); $redisInstance->set('max',10); //秒杀最大数量 $redisInstance->close(); $http->on('request', function (swoole_http_request $request, swoole_http_response $response){ $redisInstance = new Redis(); $redisInstance->connect('127.0.0.1','6379'); //随机数模拟用户ID $userId = rand(1, 10000); $remain = intval($redisInstance->decr('max'));//自减 if($remain >= 0) { $redisInstance->lpush('usersId',$userId); }else{ echo "秒杀已结束\n"; } $redisInstance->close(); }); $http->start(); 截图 截图中,列表usersId长度为10与秒杀限卖数量相同,max自减为-47430,一个发送了47440个请求,只有10个请求有效 注意进行秒杀数量判断的时候,条件必须是经过redis操作后改变的值,否则并发下判断条件无法正确判断,如下 $http = new swoole_http_server("0.0.0.0", 9999); $redisInstance = new Redis(); $redisInstance->connect('127.0.0.1','6379'); $redisInstance->set('max',10); //秒杀最大数量 $redisInstance->close(); $http->on('request', function (swoole_http_request $request, swoole_http_response $response){ $redisInstance = new Redis(); $redisInstance->connect('127.0.0.1','6379'); //随机数模拟用户ID $userId = rand(1, 10000); $remain = intval($redisInstance->get('max')); if($remain >= 1) { //不能使用这种方式,并发情况下$remain在完成lpush并进行decr以前,存在同时满足条件的情况 $redisInstance->lpush('usersId',$userId); }else{ echo "秒杀已结束\n"; } $redisInstance->decr('max'); $redisInstance->close(); }); $http->start();]]></content>
      <categories>
        <category>php</category>
      </categories>
      <tags>
        <tag>php</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[买卖股票最佳时机]]></title>
    <url>%2F2020%2F04%2F05%2F%E4%B9%B0%E5%8D%96%E8%82%A1%E7%A5%A8%E6%9C%80%E4%BD%B3%E6%97%B6%E6%9C%BA%2F</url>
    <content type="text"><![CDATA[买卖股票的最佳时机 题目给定一个数组，它的第 i 个元素是一支给定股票第 i 天的价格。 如果你最多只允许完成一笔交易（即买入和卖出一支股票一次），设计一个算法来计算你所能获取的最大利润。 注意：你不能在买入股票前卖出股票。 示例 1: 输入: [7,1,5,3,6,4]输出: 5解释: 在第 2 天（股票价格 = 1）的时候买入，在第 5 天（股票价格 = 6）的时候卖出，最大利润 = 6-1 = 5 。 注意利润不能是 7-1 = 6, 因为卖出价格需要大于买入价格。示例 2: 输入: [7,6,4,3,1]输出: 0解释: 在这种情况下, 没有交易完成, 所以最大利润为 0。 思路数组有N个数,那么一种可能为第N个数与前面N-1个数中最小值的差值，当N为N-1时，另一种可能为第N-1个数与前面N-2个数中最小的差值依次类推，穷举从N到第一个数分别于他们前面数组中最小值得差值，然后找出所有差值中的最大值，如果最大值小于则不买入股票利润为0 最优子结构为,第N个数与前N-1个数最小值的差值状态变化为N方程为 dp(n) = max(a[n] - min(m),dp(n-1)) m∈[1,n-1]base条件:数组长度小于等于1返回0问题：当数组过大，内存问题php无法使用函数计算前N-1个数的最小值，预先只需要通过遍历比较当前位数的值与前N个数中的最小值，存储一个前n位数的最小值的hash表 php版本class Solution { public $minHash=[]; public $isMinHash = false; /** * @param Integer[] $prices * @return Integer */ function maxProfit(&amp;$prices) { if($this->isMinHash == false){ $this->setMinHash($prices); } return $this->faker(count($prices),$prices); } function faker($len,&amp;$prices){ if($len &lt;= 1){ return 0; } return $this->max($prices[$len - 1] - $this->minHash[$len - 2],$this->faker($len - 1,$prices)); } function max($a,$b){ $max = $a > $b ? $a : $b; return $max &lt; 0 ? 0 : $max; } function setMinHash(&amp;$prices){ $this->minHash[0] = $prices[0]; for($i = 1; $i &lt; count($prices); $i++){ if($prices[$i] &lt; $this->minHash[$i-1]){ $this->minHash[$i] = $prices[$i]; }else{ $this->minHash[$i] = $this->minHash[$i-1]; } } $this->isMinHash = true; } } golang版本var minMap map[int]int func maxProfit(prices []int) int { setMinMap(prices) return faker(prices,len(prices)) } func faker(prices []int, digo int) int{ if digo &lt;= 1 { return 0 } if digo == 2 { max := prices[1] - prices[0] if max &lt; 0 { max = 0 } return max } max := prices[digo - 1] - minMap[digo - 2] tmp := faker(prices, digo - 1) if max &lt; tmp { max = tmp } if max &lt; 0 { max = 0 } return max } func setMinMap(prices []int){ minMap = make(map[int]int) if len(prices) &lt;= 0 { return } minMap[0] = prices[0] for i := 1; i &lt; len(prices); i ++ { if minMap[i - 1] &lt; prices[i] { minMap[i] = minMap[i-1] }else{ minMap[i] = prices[i] } } }]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>动态规划</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[linux大文件分割与恢复]]></title>
    <url>%2F2019%2F04%2F24%2Flinux%E5%A4%A7%E6%96%87%E4%BB%B6%E5%88%86%E5%89%B2%2F</url>
    <content type="text"><![CDATA[linux利用split命令进行大文件分割为有序后缀的小文件,利用cat命令进行文件恢复 分割假如存在大文件100G move.avi,执行如下命令 split -b 50G -d -a 3 move.avi move.avi. 会生成move.avi.000 move.avi.001两个每个文件大小为50G -b 分割文件大小-d 指定分割文件后缀为数字，从开始-a 3 指定分割文件后缀数字长度,为3代表后缀从000 恢复分割文件move.avi.000 move.avi.001 cat move.avi.* > move.avi]]></content>
      <tags>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[phpstorm+docker+php+xdebug]]></title>
    <url>%2F2019%2F03%2F31%2Fphpstorm-docker-php-xdebug%2F</url>
    <content type="text"><![CDATA[phpstorm配合docker中xdebug插件进行php代码调试 xdebug插件及配置zend_extension=xdebug.so xdebug.remote_enable=on xdebug.remote_port=9003 # docker宿主机ip xdebug.remote_host=172.17.0.1 xdebug.idekey=PHPSTORM 配置server File | Settings | Languages &amp; Frameworks | PHP | Servers add, Host:127.0.0.1 Port:9999(ports 9999:80) path mapping dir1 dir2 (volumes dir1:dir2) 配置Debug File | Settings | Languages &amp; Frameworks | PHP | Debug xdebug debug port:9003(与xdebug.remote_port一致) 配置Run configure Run | Edit configurations add, PHP Remote Debug enable Filter Debug Connection by IDE key choose server and write xdebug.idekey validateRun | DebugBrowser 安装 xdebug helper options phpstorm and config key (xdebug.idekey)]]></content>
      <categories>
        <category>php</category>
      </categories>
      <tags>
        <tag>github</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[mysql相关]]></title>
    <url>%2F2018%2F11%2F30%2Fmysql%E2%95%A7%CE%B1%E2%95%A3%E2%95%AA%2F</url>
    <content type="text"><![CDATA[mysql开发过程中遇见的问题 查询表中去重查询,id最大的记录SELECT MAX(id),field FROM TABLE GROUP BY field; thread_stack The stack size for each thread. The default of 192KB (256KB for 64-bit systems) is large enough for normal operation. If the thread stack size is too small, it limits the complexity of the SQL statements that the server can handle, the recursion depth of stored procedures, and other memory-consuming actions. show variables like &quot;thread_stack&quot; 修改配置文件mysql_stack=512k]]></content>
      <tags>
        <tag>mysql</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[排序算法]]></title>
    <url>%2F2018%2F11%2F25%2F%E2%94%BC%E2%94%BC%E2%95%A8%E2%89%A5%E2%95%A6%CF%80%E2%95%96%C2%BF%2F</url>
    <content type="text"><![CDATA[很多其他算法都是对排序后的数据进行处理,如二分查找,排序算法分析与代码实现 冒泡排序分析 冒泡排序通过多次遍历数据,对相邻的两个数进行比较,进行值交换找到此次遍历最大或者最小的数犹如冒泡 遍历的次数为数据数量减1 每次遍历需要操作的数减1 冒泡排序的时间复杂度为O(n^2) 代码如下 快速排序分析快速排序]]></content>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[golang中mysql链接数设置]]></title>
    <url>%2F2018%2F11%2F13%2Fgolang%E2%95%93%E2%95%A8mysql%E2%94%B4%E2%94%A4%E2%95%9C%E2%95%99%E2%95%A9%C2%B2%E2%95%94%CE%A6%E2%95%93%E2%94%9C%2F</url>
    <content type="text"><![CDATA[golang中设置mysql的最大连接数与最大闲置连接数,以及mysql最大连接数配置与连接状态查看 golang连接数设置max open connections与mysql服务器最大连接数 max idle connections 当没有数据库请求需要处理，与mysql保持的最大闲置连接数，为下次数据库处理做好准备 数量小于等于 max open connections 代码 dsn := "" db,_ := sql.Open("mysql",dsn) //最大连接数 db.SetMaxOpenConns(300) //闲置连接数 db.SetMaxIdleConns(200) mysql最大连接数查看与设置查看show variables like &quot;max_connections&quot;; 设置set global max_connections=400; 查看连接状态show status 仅当前客户端连接到服务器,Threads_connected为1 golang死循环开启与mysql连接,设置最大链接数300sqlTest := "SELECT id FROM yc_posts_posts where id > 10 limit 1" for { db.Query(sqlTest) } time.Sleep(1e9 * 1000) 加上客户端一共301 也可以使用show processlist查看连接的具体信息]]></content>
      <tags>
        <tag>golang</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[goquery_tips]]></title>
    <url>%2F2018%2F11%2F12%2Fgoquery-tips%2F</url>
    <content type="text"><![CDATA[goquery一些零碎的知识点 删除一个子元素//doc selector selector.Find(".remove").Remove() 获取dom 子htmlht,err := selector.Html() 获取当前dom htmlht,err := goquery.OuterHtml(selector)]]></content>
      <tags>
        <tag>golang</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[God is dead]]></title>
    <url>%2F2018%2F10%2F24%2Fgod-is-dead%2F</url>
    <content type="text"><![CDATA[God is dead. God remains dead. And we have killed him God is dead. God remains deadAnd we have killed himHow shall we comfort ourselves, the murderers of all murderers?What was holiest and mightiest of all that the world has yet owned has bled to death under our knives: who will wipe this blood off us?What water is there for us to clean ourselves?What festivals of atonement, what sacred games shall we have to invent?Is not the greatness of this deed too great for us?Must we ourselves not become gods simply to appear worthy of it?— Nietzsche]]></content>
      <categories>
        <category>others</category>
      </categories>
      <tags>
        <tag>Nietzsche</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[word代码语法高亮]]></title>
    <url>%2F2018%2F10%2F22%2Fword%E2%94%A4%C2%B7%E2%94%AC%CE%B4%E2%95%99%E2%88%A9%E2%95%96%C2%BF%E2%95%95%E2%96%80%E2%94%B4%E2%94%B4%2F</url>
    <content type="text"><![CDATA[syntax highlight code for word documents 语法支持目前支持: c c++ c# css delphi pascal xml java javascript php python ruby sql vb html 效果 在线地址planetb.ca]]></content>
      <categories>
        <category>others</category>
      </categories>
      <tags>
        <tag>word</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[php操作excel]]></title>
    <url>%2F2018%2F10%2F22%2Fphp%E2%96%93%E2%94%98%E2%95%AB%E2%89%88excel%2F</url>
    <content type="text"><![CDATA[PHP操作excel的工具很多，在此使用php一个工具phpSpreadsheet,不仅能操作excel还包括一些其他格式如csv,pdf,sylk等 工具介绍 PhpSpreadsheet is a library written in pure PHP and providing a set of classes that allow you to read from and to write to different spreadsheet file formats, like Excel and LibreOffice Calc. 官方地址 composer拉取composer require phpoffice/phpspreadsheet 简单使用读取文件 $o_spreadsheet = PhpOffice\PhpSpreadsheet\IOFactory::load($s_path); $a_sheetData = $o_spreadsheet->getActiveSheet()->toArray(null, true, true, true); 保存文件use PhpOffice\PhpSpreadsheet\Cell\DataType; use PhpOffice\PhpSpreadsheet\Spreadsheet; $o_spreadsheet = new Spreadsheet(); $o_spreadsheet->setActiveSheetIndex(0) ->setCellValue('A1', '姓名') ->setCellValue('B1', '身份证号') ->setCellValue('C1', '手机号'); $a_templateData = [ ['乔峰', '51132119941020365X', '18180549051'], ['需组', '51132119941020300x', '18180549051'], ['短语', '511321199410203654', '18180549051'] ]; foreach ($a_templateData as $i_key => $a_value): $o_spreadsheet->setActiveSheetIndex(0) ->setCellValue('A'.($i_key+2),$a_value[0]) ->setCellValueExplicit('B'.($i_key+2),$a_value[1],DataType::TYPE_STRING) ->setCellValueExplicit('C'.($i_key+2),$a_value[2],DataType::TYPE_STRING); endforeach; $o_spreadsheet->getActiveSheet()->setTitle("导入抽奖人员模板"); // Redirect output to a client’s web browser (Xls) header('Content-Type: application/vnd.ms-excel'); header('Content-Disposition: attachment;filename="导入抽奖人员模板.xls"'); header('Cache-Control: max-age=0'); // If you're serving to IE 9, then the following may be needed header('Cache-Control: max-age=1'); // If you're serving to IE over SSL, then the following may be needed header('Expires: Mon, 26 Jul 1997 05:00:00 GMT'); // Date in the past header('Last-Modified: ' . gmdate('D, d M Y H:i:s') . ' GMT'); // always modified header('Cache-Control: cache, must-revalidate'); // HTTP/1.1 header('Pragma: public'); // HTTP/1.0 $writer = IOFactory::createWriter($o_spreadsheet, 'Xls'); $writer->save('php://output'); exit; 创建并下载文件use PhpOffice\PhpSpreadsheet\Cell\DataType; use PhpOffice\PhpSpreadsheet\Spreadsheet; $o_spreadsheet = new Spreadsheet(); $o_spreadsheet->setActiveSheetIndex(0) ->setCellValue('A1', '姓名') ->setCellValue('B1', '身份证号') ->setCellValue('C1', '手机号'); $a_templateData = [ ['乔峰', '51132119941020365X', '18180549051'], ['需组', '51132119941020300x', '18180549051'], ['短语', '511321199410203654', '18180549051'] ]; foreach ($a_templateData as $i_key => $a_value): $o_spreadsheet->setActiveSheetIndex(0) ->setCellValue('A'.($i_key+2),$a_value[0]) ->setCellValueExplicit('B'.($i_key+2),$a_value[1],DataType::TYPE_STRING) ->setCellValueExplicit('C'.($i_key+2),$a_value[2],DataType::TYPE_STRING); endforeach; $o_spreadsheet->getActiveSheet()->setTitle("导入抽奖人员模板"); // Redirect output to a client’s web browser (Xls) header('Content-Type: application/vnd.ms-excel'); header('Content-Disposition: attachment;filename="导入抽奖人员模板.xls"'); header('Cache-Control: max-age=0'); // If you're serving to IE 9, then the following may be needed header('Cache-Control: max-age=1'); // If you're serving to IE over SSL, then the following may be needed header('Expires: Mon, 26 Jul 1997 05:00:00 GMT'); // Date in the past header('Last-Modified: ' . gmdate('D, d M Y H:i:s') . ' GMT'); // always modified header('Cache-Control: cache, must-revalidate'); // HTTP/1.1 header('Pragma: public'); // HTTP/1.0 $writer = IOFactory::createWriter($o_spreadsheet, 'Xls'); $writer->save('php://output'); exit; 函数/** * 模板下载 * * @param array $a_header 模板头 * @param array $a_data 模板数据 * @param string $s_title 标题 * @param array $width 宽度 */ function template(array $a_header, array $a_data, string $s_title = "模板",$width=[]) { $o_spreadsheet = new Spreadsheet(); $o_t = $o_spreadsheet->setActiveSheetIndex(0); $i_char = ord('A'); foreach ($a_header as $s_name) { $o_t->setCellValue(chr($i_char) . '1', $s_name); $i_char++; } foreach ($a_data as $i_key => $a_value): $o_t = $o_spreadsheet->setActiveSheetIndex(0); $i_char = ord('A'); foreach ($a_value as $i_key2 => $s_value): $o_t->setCellValueExplicit(chr($i_char) . ($i_key + 2), $s_value, DataType::TYPE_STRING); $i_char++; endforeach; endforeach; $index = ord('A'); if(!empty($width)){ foreach ($a_header as $key=>$item){ $o_spreadsheet->getActiveSheet()->getColumnDimension(chr($index))->setWidth($width[$key]); $index++; } } $o_spreadsheet->getActiveSheet()->setTitle($s_title); // Redirect output to a client’s web browser (Xls) header('Content-Type: application/vnd.ms-excel'); header('Content-Disposition: attachment;filename="' . $s_title . '.xlsx"'); header('Cache-Control: max-age=0'); // If you're serving to IE 9, then the following may be needed header('Cache-Control: max-age=1'); // If you're serving to IE over SSL, then the following may be needed header('Expires: Mon, 26 Jul 1997 05:00:00 GMT'); // Date in the past header('Last-Modified: ' . gmdate('D, d M Y H:i:s') . ' GMT'); // always modified header('Cache-Control: cache, must-revalidate'); // HTTP/1.1 header('Pragma: public'); // HTTP/1.0 $writer = IOFactory::createWriter($o_spreadsheet, 'Xlsx'); $writer->save('php://output'); exit; }]]></content>
      <categories>
        <category>php</category>
      </categories>
      <tags>
        <tag>php</tag>
        <tag>excel</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[抽奖算法]]></title>
    <url>%2F2018%2F10%2F20%2F%E2%94%82%CE%98%E2%95%9C%E2%96%92%E2%95%A6%CF%80%E2%95%96%C2%BF%2F</url>
    <content type="text"><![CDATA[通过程序进行抽奖比较常见，算法可能比较多的实现，以下通过一种比较简单取随机数的方法进行抽奖算法的实现 实现功能该代码可以实现任意权重的抽奖(包含权重为小数),如果权重为小数,对所有权重以10其最小权重的小数位数的幂次方放大,例如0.1所有权重放大10倍 实现原理 1.计算所有奖项的权重和 2.将奖项按照权重的大小降序排序 3.取１到权重和的随机数 4.迭代奖项将随机数与每个迭代项的权重进行比较，如果小于该迭代项的权重则返回该奖项，权重和减去该迭代项 代码如下&lt;?php class Lottery { //奖项=>权重 private $a_sets; //初始化，奖项对应的各项权重 public function __construct(array &amp;$a_sets){ //如果中奖权重中有小数，则找出其中最小的数，对所有中奖权重进行基于其进行10倍数进行放大使所有权重都为整数 //找出最小的数 $a_weights = array_values($a_sets); $i_min = $a_weights[0]; //找出最小数 (function()use(&amp;$a_weights,&amp;$i_min){ foreach($a_weights as $i_item): if($i_item &lt; $i_min) $i_min = $i_item; endforeach; })(); //判断小数位数 $a_tmp = explode(".",$i_min); $i_size = count($a_tmp) == 2 ? strlen($a_tmp[1]): 0; //放大所有权重为整数 if($i_size > 0): array_walk($a_sets,function(&amp;$i_item)use(&amp;$i_size){ $i_item = intval($i_item * pow(10,$i_size)); }); endif; //按照权重降序排序 krsort($a_sets); $this->a_sets = $a_sets; } //抽奖 public function draw(){ //总的权重 $i_totalWeight = array_sum($this->a_sets); foreach($this->a_sets as $prize => $i_weight): $i_rand = mt_rand(1,$i_totalWeight); if($i_rand &lt;= $i_weight): return $prize; endif; $i_totalWeight -= $i_weight; endforeach; } } $a_testSets = [ 4 => 101, 3 => 70, 2 => 50, 1 => 0.1 ]; $o_lottery = new Lottery($a_testSets); $i_prize = $o_lottery->draw();//抽奖]]></content>
      <categories>
        <category>php</category>
      </categories>
      <tags>
        <tag>php 抽奖</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[linux下SSH免密登录]]></title>
    <url>%2F2018%2F10%2F18%2Flinuxssh%E2%94%9C%CE%93%E2%94%9C%E2%96%84%E2%95%A1%E2%95%9F%E2%94%AC%E2%95%9D%2F</url>
    <content type="text"><![CDATA[ssh每次远程登录输入内容比较繁琐，可以自己简单配置远程主机登录授权 本机生成ssh钥匙对ssh-keygen -t rsa -b 4096 将公钥添加到远程主机授权keys中，即.ssh/authorized_keys中ssh-copy-id -i ~/.ssh/id_rsa.pub -p24 root@120.26.79.188 测试是否成功ssh -p24 root@120.26.79.188 远程主机登录脚本 保存为sh脚本, chmod +x command –help,获取用法 #! /bin/bash # 远程主机数组 declare -A hosts # ip 端口 用户名 hosts["winneroad188"]='120.26.79.188 24 root' hosts["winneroad158"]='192.168.1.58 24 winneroad' # 登录函数 function login(){ is=0 for i in ${!hosts[@]};do if [ "$1" = "$i" ];then is=1 break fi done if [ $is -eq 0 ];then echo "主机名[$1]不存在" return fi n=0 declare -A arr # 将字符串转换为数组 for x in ${hosts[$1]};do arr[$n]=$x n=$[n+1] done # 拼裝命令 comm="ssh ${arr[2]}@${arr[0]} -p${arr[1]}" # 执行ssh命令 ${comm} } # 列出现有主机 function list(){ echo "共保存主机:"${#hosts[@]}个 n=1 for i in ${!hosts[@]};do echo [$n]'=>'$i n=$[n+1] done } # 列出现有主机 if [ "$1" = "ls" ];then list elif [ "$1" = "-n" ];then t=1 # 主机名 key='' for i in ${!hosts[@]};do if [ $2 -eq $t ];then key=$i break fi t=$[t+1] done if [ ! $key ];then echo "主机名错误" else login $key fi elif [ "$1" = "--help" ];then echo "Usage ssh.sh OPTION" echo "ls 显示存储的远程主机" echo "-n number 根据序号登录远程主机 " else login $1 fi]]></content>
      <categories>
        <category>shell</category>
      </categories>
      <tags>
        <tag>ssh</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[redis知识点]]></title>
    <url>%2F2018%2F10%2F06%2Freidis%E2%95%93%C2%AC%E2%95%A9%E2%95%A2%E2%95%A1%CF%80%2F</url>
    <content type="text"><![CDATA[redis一些简单的知识点记录 redis配置文件官方配置文档 //启动server指定配置文件 redis-server ./redis.conf //查看所有配置 config get * //查看某一项配置 config get dir //设置配置,并非素有配置都能动态设置,详细参考官方配置文档 config set dir ... //动态设置配置仅仅当前服务生效，如果要保存配置到配置文件,必须在启动server时候制定配置文件 config rewrite 安全密码授权//设置密码 config set requirepass password //授权 auth password protected-modeprotected-mode是一种客户端连接保护措施,配置文件默认开启protected-mode yes,有以下两种条件者,仅127.0.0.1和::1能访问,其他客户端链接讲访问error 配置文件没有清楚的绑定能访问的客户端例如bind 127.0.0.1 配置文件没有设置requirepass 关闭protected-mode no]]></content>
      <categories>
        <category>others</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[golang tips]]></title>
    <url>%2F2018%2F09%2F23%2Fgolang%20tips%2F</url>
    <content type="text"><![CDATA[golang一些简单的知识点记录 make与new new类型分配变量零值，返回指针 make 只用于smc slice map chan 三种类型 int与int64转stringw strconv.FormatInt(int64, 10) string strconv.Itoa(int) string 类型转化 类型转化,v.(type) 需要转换的类型 type data map[string]interface{} var sub = data{ "zhangsan":"张三", "lisi":"李四", } var parent data parent["sub"] = sub for k, v := range parent["data"].(data) { fmt.Printf("%s,%s", k, v) } 类型断言 //单一类型断言,断言变量类型一定要是接口类型，因此讲此变量赋值给一个空接口变量 type emptyInterface interface{}//空接口 var v emptyInterface v = variable if _,ok := v.(string);ok{ printf("variable is type of string") }else { printf("variable is not type of string") } //多类型断言 switch i := v.(type) { case "int32": case "float64": } 字符串转整形 strconv.ParseInt(s string, base int, bitSize int) int64 error s 要转换的的字符串 base 字符串类型，可选0 8 10 16, 其中8、10、16 代表字符串进制如果为0将通过string前缀自行判断，如0代表８进制，0x１６进制 bitSize 整形的位数，8 16 32 64,如果整数大于位数能代表最大数字，如(“128”,10,8)将返回bitSize所能代表的最大数字127 生成范围内随机整数func randInt(start, end int) (i int) { r := rand.New(rand.NewSource(time.Now().UnixNano())) if start > end { return end } i = r.Intn(end-start) + start return } 获取程序传入参数 func Int(name string, value int, usage string) *int func String(name string, value string, usage string) *string total := flag.Int("total", 100000, "how many log want to create") filePath := flag.String("filePath", "/home/jianglong/log/nginx/dig2", "log file path") flag.Parse() fmt.Println(*total, *filePath) 文件管理写入文件追加写入 func (f *File) Write(b []byte) (n int, err error) file, err := os.OpenFile(*filePath, os.O_RDWR|os.O_APPEND|os.O_CREATE, 0644) if err != nil { fmt.Println(err) } defer file.Close() logStr := "我是追加的方式写入的内容,如果不存在就创建文件" _,err := file.Write([]byte(logStr)) if err != nil { fmt.Println(err) } 覆盖文件 func WriteFile(filename string, data []byte, perm os.FileMode) error err := ioutil.WriteFile(file_path,[]byte("我是覆盖写入的内容"),0644) if err != nil { fmt.Println(err) } md5hasher := md5.New() hasher.Write([]byte("i am the content)) md5str := hex.EncodeToString(hasher.Sum(nil)) 变长参数内容参照 package main import "fmt" func main() { x := min(1, 3, 2, 0) fmt.Printf("The minimum is: %d\n", x) slice := []int{7,9,3,5,1} x = min(slice...) fmt.Printf("The minimum in the slice is: %d", x) } func min(s ...int) int { if len(s)==0 { return 0 } min := s[0] for _, v := range s { if v < min { min = v } } return min } 时间相相关格式化时间time.Now().Format("2006-01-02 15:04:05") 时间转时间戳loc, _ := time.LoadLocation("Local") theTime, _ := time.ParseInLocation("2006-01-02 15:04:05", ts, loc) theTime.Unix() ` 修剪字符串strings.Trim("hello","h") string strings.TrimLeft("hello","h") string strings.TrimRight("hello","o") string io.Reader多次ioutil.ReadAllif body, err := ioutil.ReadAll(io.Reader); err == nil { twice := bytes.NewReader(body) twiceBody, err := ioutil.ReadAll(twice) } io.Reader to string or []bytebytes,err := ioutil.ReadAll(io.Reader) string(bytes) 获取变量类型import ( "reflect" "fmt" ) func main(){ data := [...]int{1,2,3} //array fmt.Println("%v",reflect.TypeOf(data).Kind()) //获取data的变量类型 array fmt.Println("%v",reflect.TypeOf(data).Elem().Kind()) //获取underlying type int } 获取执行时间import ( "time" ) func main() { t := time.Now() //do something println(time.Since(t)) } 线程并发锁### 当全局变量被对个线程同时访问的时候可能会造成未知错误，如下例子,一共自增20次，但结果不一定是20 func main(){ number := 0 for i:=0; i]]></content>
      <categories>
        <category>golang</category>
      </categories>
      <tags>
        <tag>tips</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[golang web middleware]]></title>
    <url>%2F2018%2F09%2F18%2Fgolang%20%20web%20middleware%2F</url>
    <content type="text"><![CDATA[golang http中间件知识 个人理解golang中http中间件为一个请求链中的一环,用来对真正的请求处理进行一些预处理、如权限验证,参数处理或者辅助进行日志记录等操作,与真正的业务处理分离实现一个demo中间件，验证请求来源ip,让某个ip无法访问网站 golang http包接口分析http包代码 package http type Handler Interface{ ServeHTTP(ResponseWriter, *Request) } type HandlerFunc func(ResponseWriter, *Request) func (f HandlerFunc) ServeHTTP(w ResponseWriter,r *Request) { f(w, r) } 分析 以上为http库内置的http处理接口,其中Handler接口有一个ServeHttp接口函数，在处理请求的时候，会调用此函数对接口进行处理。 任何实现了次接口的类型都可以作为http.ListenAndServe(string, Handler)中的第二个Handler类型参数进行请求处理。 以上代码中HandlerFunc 就是包内置的默认的实现Handler接口的一种方式。也可以自定义。 自定义实现Handler,不使用http包内的HandlerFunc代码 type MyHandler struct { } func (mh *MyHandler) ServeHTTP(w http.ResponseWriter, r *http.Request) { //do something // return result w.String(200, "hello world") } func main() { http.ListenAndServe(":1234",&MyHandler{}) } 分析 以上MyHandler实现了HTTP包中Handler接口(ServeHTTP方法)，定义了自己处理接口逻辑 使用函数型代码 //handler Func func MyHandlerFunc(h http.HandlerFunc) http.HandlerFunc { return func(rw http.ResponseWriter, req *http.Request) { //do something for example print verse rw.Write([]byte("昨夜星辰昨夜风")) h(rw, req) } } func main() { err := http.ListenAndServe(":12345", MyHandlerFunc(func(rw http.ResponseWriter, req *http.Request) { w.Write([]byte("hell world 123456")) })) if err != nil{ log.Fatal(err) } } 分析 以上没有实现自己的Handler,而是实现了与http.handlerFuc相同签名的函数，相当于使用了http包内实现的HandlerFunc,http包会调用Handler的ServeHTTP方法，然后在ServeHTTP中调用HandlerFuc 总结 http.ListenAndServe(“”,Handler),中的Handler可以传两类，第一类是实现http.Handler的ServeHTTP方法的任意类型，第二类是与http.HandlerFuc具有相同签名的函数，以为http.HandlerFuc实现了http.Handler的ServeHTTP,不需要我们再去实现。 而所谓的http中间件,就是重新实现实现Handler接口或者定义将真正的业务处理部分函数HandlerFunc作为参数传递给中间件函数壳在壳内进行附加操作后，如果满足需求或者其他，然后再调用处理部分函数。]]></content>
      <categories>
        <category>golang</category>
      </categories>
      <tags>
        <tag>middleware</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[函数型接口]]></title>
    <url>%2F2018%2F09%2F17%2F%E2%95%91%C2%BB%E2%95%A9%C2%B2%E2%95%A8%E2%95%90%E2%95%9C%E2%95%99%E2%94%90%E2%94%8C%2F</url>
    <content type="text"><![CDATA[golang中只要类型实现了接口包含的所有抽象方法。那么该类型便属于该接口的实现类 函数型接口： 某个函数类型作为接收者实现了接口方法 个人理解，函数形接口主要是类似于面向接口编程中，调用实现接口的方法而完成多态，但又不像传统面向接口编程那样显得臃肿，需要先声明类继承接口然后在类中实现方法，golang中任何与接口方法签名相同的函数都可以作为被调用者。 demo为计算一个二位数组，每个子项数组的和，然后返回结果数组,例如[[1,2,3],[4,5,6],[7,8,9]] 返回[6,15,24] 面向接口编程首先实现传统的面向接口编程： 声明接口 声明一个类型，实现接口函数 // 计算接口 type Sum interface { Add(m map[int][]int) map[int]int } //声明类型用来实现接口 type R string func (r R) Add(m map[int][]int) (n map[int]int){ n = make(map[int]int) if m != nil && len(m) > 0 { for i,v := range m { if v == nil || len(v) == 0 { n[i] = 0 } else { n[i] = 0 for _,v1 := range v { n[i] = n[i] + v1 } } } } return } // 调用 func Call(m map[int][]int, sum Sum) map[int]int{ return sum.Add(m) } func main() { m := make(map[int][]int) m[0] = []int{1,2,3} m[1] = []int{4,5,6} m[2] = []int{7,8,9} re := Call(m, R("demo")) fmt.Printf("%v", re) } // 结果 map[2:24 0:6 1:15] 以上为典型的面向接口编程，Call函数依赖抽象接口类型Sum,R实现接口，作为参数传递给Call 但是这里R类型似乎是多余的，因为golang并没有所谓class关键字，必须要又一种类型来作为接受者来实现对应Sum接口的方法而且类的实现有一些多余 函数型接口声明函数类型 // 计算接口 type Sum interface { Add(m map[int][]int) map[int]int } // 声明函数 type Handle func(map[int][]int) map[int]int func (h Handle) Add(m map[int][]int) map[int]int { return h(m) } // 调用不变 func Call(m map[int][]int, sum Sum) map[int]int{ return sum.Add(m) } // 我的方法进行处理 func myHandle(m map[int][]int) map[int]int{ n := make(map[int]int) if m != nil && len(m) > 0 { for i,v := range m { if v == nil || len(v) == 0 { n[i] = 0 } else { n[i] = 0 for _,v1 := range v { n[i] = n[i] + v1 } } } } return n } func main() { m := make(map[int][]int) m[0] = []int{1,2,3} m[1] = []int{4,5,6} m[2] = []int{7,8,9} re := Call(m, Handle(myHandle))//讲myHandle转换为Handle类型，赋值给Sum类型变量 fmt.Printf("%v", re) } //结果 map[0:6 1:15 2:24] 分析 以上没有多余的类型R,而且只要实现任意与Handle签名相同的函数,都可以将其转换为Handle类型，而Handle又实现了接口Sum， 整个流程 Call() =&gt; Sum.Add() =&gt; myHandle() 我们就只需要在调用Call实现Handle签名函数，与Sum接口解耦 整理type SumIn map[int][]int type SumOut map[int]int type Sum interface { Add(SumIn) SumOut } //声明函数 type Handle func(SumIn) SumOut func (h Handle) Add(m SumIn) SumOut { return h(m) } // 调用 func Call(m SumIn, sum Sum) SumOut { return sum.Add(m) } //内部进行类型转换 func CallFunc(m SumIn,f func(SumIn) SumOut) SumOut{ return Call(m,Handle(f)) } // 我的方法进行处理 func myHandle(m SumIn) SumOut { n := make(SumOut) if m != nil && len(m) > 0 { for i,v := range m { if v == nil || len(v) == 0 { n[i] = 0 } else { n[i] = 0 for _,v1 := range v { n[i] = n[i] + v1 } } } } return n } func main() { m := make(SumIn) m[0] = []int{1,2,3} m[1] = []int{4,5,6} m[2] = []int{7,8,9} re := CallFunc(m, myHandle)//内部进行转换 fmt.Printf("%v", re) } 分析 主要对Call函数进行了封装将Handle签名相同的函数转换，换到了内部，不需要在调用进行转换和定义了类型别名 这种函数型接口相当于对接口的功能实现进行了热拔插，适用于只有一个方法的接口]]></content>
      <categories>
        <category>golang</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[通过ngrok自己动手搭建内网穿透服务]]></title>
    <url>%2F2018%2F04%2F16%2Flinux%20ngrok%20%E2%94%A4%CE%B5%E2%95%9C%C2%BF%2F</url>
    <content type="text"><![CDATA[这几天一直在折腾ngrok，记录下整个过程 最先怕影响服务器，是在docker里进行安装的，实例跑的是ubuntu16.04 大概流程图 访问服务器(80|443)端口 ，apache按规则对需要进行代理的请求发送给docker docker是与服务8080端口进行了映射，而docker内的ngrok服务监听了8080端口 ngrok服务设置与ngrok客户端建立隧道的端口是4443 ngrok将apache代理的请求按规则转发给ngrok客户端，客户端再与本地端口进行转发关联 最终将处理结果依次返回 用docker出现的问题 由于ngrok需要根据域名的不同对代理进行转发，配置了hosts文件，例如wx.ngrok.com 到 0.0.0.0:8080。docker内开启ngrok服务后，客户端成功进行了连接，但当进行url请求的时候始终无法从ngrok服务端转发到ngrok客户端，最先是用80端口报不是tsl/ssl握手，最后换做443报什么read message EOF之类，研究很久最终放弃 最终环境 ubuntu14.04 golang 1.7 最先利用ubuntu apt install golang 安装的是1.5的go环境,报了一个错，经过搜索是golang版本问题，最后通过下载包的方式安装了1.6解决 按照教程进行了一系列操作参考教程,编译linux,windows客户端成功 当编译Mac客户端后运行报错什么什么runtime之类的，macos 10.13,又折腾半天不行，然后怀疑go语言版本低了，然后又下载了1.7进行了解压放在/usr/local目录下 配置go的环境变量GOROOT后，进行客户端编译，报错C source files not allowed when not using cgo or SWIG又是一顿搜索 最后解决方式为把go1.7解压到/usr/lib目录下配置好环境变量，编译成功，mac下载客户端运行成功 没用docker的流程大概是这样 由于是用apache规矩规则进行代理，只有一个公网域名的情况下，通过根目录子目录不同进行不同代理例如wx.winneroad.cn/jl代理到我的服务器,但是这样会引发一些问题，例如再用tp5进行url函数进行url生成的时候/会直接把域名下的jl顶掉，最好再解析一个域名到原服务器 一些配置截图 apache ngrokd 服务器hosts ngrok客户端连接]]></content>
      <categories>
        <category>others</category>
      </categories>
      <tags>
        <tag>ngrok</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2018学习计划]]></title>
    <url>%2F2018%2F03%2F08%2F2018%E2%95%A4%C2%BA%E2%95%A7%E2%96%91%E2%95%9D%E2%95%9E%E2%95%97%C2%AB%2F</url>
    <content type="text"><![CDATA[2017工作一年多的时间，技术上有很多进步，对编程的思想上也有很多改变，学了一些东西，但是缺少学习计划，学得很杂很大一部分是根据兴趣学的，但是不够系统和扎实，所有制定一下2018的学习计划吧,毕竟purpose很重要 准备的学习计划 2018-02-24 shell python canvas design pattern docker 提升对英文文档的阅读能力 在2017中以上的各种技术都有接触但是接触不够多，对英文阅读能力的提升也是急需提升的，好在早就已经养成了不惧怕英文的习惯,每天对学习内容进行简单描述 2018-03-08 最近由于装了黑苹果，一直在整理开发环境，最开初的时候是打算装虚拟机，但系统资源开销太大。后来准备用docker看文档折腾了几天构建了php5.6,php7.x和nginx镜像，以及一个mysql镜像，利用挂载卷的方式进行数据永久化，但是docker在mac资源还是占用较多，最后用的mamp dockerFile: dockerFile分为4部分，基础镜像、维护者信息、镜像操作指令、容器启动命令 #基础镜像 From baseImage #维护人信息 MAINTAINER name email #镜像操作执行令 RUN instruct #容器启动指令 CMD instruct docker打标签: docker tag image username/repository:tag docker push username/repository:tag]]></content>
      <categories>
        <category>others</category>
      </categories>
      <tags>
        <tag>plan</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[github 利用gpg对提交进行签名验证]]></title>
    <url>%2F2018%2F03%2F05%2Fgithub%20gpg%2F</url>
    <content type="text"><![CDATA[gpg(gun privacy guard)大概过程 利用gpg生成钥匙对，用私钥对文件签名，github用公钥进行验证 具体步骤(仅在Linux或者mac)1.生成钥匙对 gpg --gen-key 2.导出公钥 gpg -a --export ID &gt; pub.asc 3.github配置gpg keys 将步骤2中的pub.asc的内容复制到制定sfdasdfsdsdfsdf 4.配置git git config --global -e 在仓库中 gpg config commit.gpgsign = false 其他 gpg 查看keyid gpg -k --keyid-format short | long gpg 导出私钥 gpg -a --export-secret-key key-id &gt; secret.asc gpg 删除钥匙对 gpg --delete-secret-keys keys-id &amp;&amp; gpg --delete-keys keys-id]]></content>
      <categories>
        <category>git</category>
      </categories>
      <tags>
        <tag>github</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[画图分析的重要性]]></title>
    <url>%2F2018%2F02%2F24%2F%E2%95%97%C2%A1%E2%95%90%E2%95%9D%E2%95%96%E2%95%93%E2%95%AC%C3%B7%2F</url>
    <content type="text"><![CDATA[如题下: 一群猴子排成一圈，按1,2,…,n依次编号。然后从第1只开始数，数到第m只,把它踢出圈，从它后面再开始数， 再数到第m只，在把它踢出去…，如此不停的进行下去， 直到最后只剩下一只猴子为止，那只猴子就叫做大王。要求输入m、n, 输出最后那个大王的编号 在大学c++课程设计中做过类似的题，然后贫着不清晰的感觉用php进行了编程，结果是3个小时写出来是错误的，中间不停修修改改，很痛苦，总是脑袋里理不清然后又急于写代码妄想在调试过程中侥幸得出答案。 昨天回家的路上还是想了想应该先画图，先理清逻辑，然后今天早上画图花了半个小时，编程5分钟不到就修改成功了,图如下: 代码如下: class Monkey { private $next; //下一个指针 private $number; //编号 public function getNext() { return $this->next; } public function setNext($next) { $this->next = $next; } //原始编号 public function getNum() { return $this->number; } public function setNum($number) { $this->number = $number; } } //调用类 class Client { public $head; //头节点 private $m;//猴子数量 private $n;//踢号 /** * Client constructor. * @param $m int 猴子个数 * @param $n int 提出的数字 */ public function __construct($m, $n) { //初始化 $this->m = intval($m); $this->n = intval($n); //初始化头节点 $head = new Monkey(); $head->setNum(1); $this->head = $head; $this->head->setNext(Null); //添加链表 $count = $this->m; $current = $this->head; while ($count > 1): $monkey = new Monkey(); $monkey->setNext(Null); //设置编号 $newNum = $current->getNum() + 1; $monkey->setNum($newNum); $current->setNext($monkey); $current = $current->getNext(); $count--; endwhile; $current->setNext($this->head); } //便利节点 public function traverseNode() { $tmp = $this->head; //echo $tmp->getNum(); $tmp = $tmp->getNext(); while (true): //echo $tmp->getNum(); $tmp = $tmp->getNext(); endwhile; } //进行剔除 public function index() { //头和当前指针 $fronted = $current = $this->head; $count = 1; $monkey_count = $this->m; while ($monkey_count > 1): if ($count === $this->n): $fronted->setNext($current->getNext()); $current = $current->getNext(); $count = 1; $monkey_count --; else: if ($monkey_count !== $this->m): $fronted = $current; endif; $current = $current->getNext(); $count ++; endif; endwhile; echo $current->getNum(); } } $o_instance = new Client(4, 3); //$o_instance->traverseNode(); $o_instance->index(); 通过对例子进行流程图分析的方式，即使脑子是混乱的但图是清晰的，通过分析图来分析逻辑的正确性，通过图来进行编码就变得很容易了，所有遇到脑子理不清的问题还是应该先画图,画图虽然花费一定时间，但相比在脑子里理不清的时候，其所带来的直观的逻辑展示往往会帮我们在整个编程节省大量的时间]]></content>
      <categories>
        <category>php</category>
      </categories>
      <tags>
        <tag>think</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[linux scws中文分词扩展安装]]></title>
    <url>%2F2018%2F02%2F08%2Fphp%E2%95%93%E2%95%A8%E2%95%AC%E2%94%80%E2%95%96%E2%95%93%E2%94%A4%E2%95%A9%2F</url>
    <content type="text"><![CDATA[SCWS 是 Simple Chinese Word Segmentation 的首字母缩写（即：简易中文分词系统）。 这是一套基于词频词典的机械式中文分词引擎，它能将一整段的中文文本基本正确地切分成词。 词是中文的最小语素单位，但在书写时并不像英语会在词之间用空格分开， 所以如何准确并快速分词一直是中文分词的攻关难点。 安装环境ubuntu16.04 安装scws-1.2.3 wget -q -O - http://www.xunsearch.com/scws/down/scws-1.2.3.tar.bz2 | tar xjf - cd scws-1.2.3 ./configure --prefix=/usr/local/scws make &amp;&amp; sudo make install php -m | grep scws 安装php扩展检测phpize which phpize &amp;&amp; sudo apt install php-dev cd phpext &amp;&amp; phpize &amp;&amp; ./configure --with-scws=/usr/local &amp;&amp; make &amp;&amp; sudo make install 在php.ini添加扩展即可(extension = EXTENSION_PATH) scws官方网站 更多教程]]></content>
      <categories>
        <category>php</category>
      </categories>
      <tags>
        <tag>php</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[结构设计模式之适配器模式]]></title>
    <url>%2F2018%2F02%2F06%2F%E2%95%A9%E2%95%A9%E2%94%BC%CE%A3%E2%95%9E%E2%89%88%E2%94%80%C3%BA%E2%95%A9%E2%95%9C%2F</url>
    <content type="text"><![CDATA[Wikipedia In software engineering, structural design patterns are design patterns that ease the design by identifying a simple way to realize relationships between entities. 结构设计模式关注对象之间的组合,也就是对象之间的相互使用 适配器模式让已存在的不兼容对象，在不修改代码的情况下通过适配器的wrap让其能够兼容 例如：一个猎人打猎，现在猎物存在狮子，但存在另一个野猪类，在不改动已存在的猎人接口和狮子与野猪接口的同时让猎人也能够猎野猪 php代码 //狮子接口 interface Lion { //咆哮 function roar():string; } //非洲狮 class AfricaLion implements Lion{ public function roar():string { return "正在咆哮的非洲狮\n"; } } //美洲狮子 class AmericaLion implements Lion { public function roar():string { return "正在咆哮的美洲狮\n"; } } //猎人 class Hunter { //打猎 public function hunt(Lion $lion):void{ echo "猎人杀死了一头".$lion->roar(); } } //猎人实例化 $o_hunter = new Hunter(); //非洲狮 $o_africaLion = new AfricaLion(); //美洲狮 $o_americaLion = new AmericaLion(); //打猎行为 $o_hunter->hunt($o_africaLion); $o_hunter->hunt($o_americaLion); //==============现存在野猪的打猎，且不修猎人,野猪接口,因为打猎方法的参数约束为Lion,但野猪并不是狮子，增加适配器进行适配 //已存在野猪接口 interface WildPig { //吃 function eat():string; } class ChinaWildPig implements WildPig{ function eat():string { return "正在吃草的中国野猪\n"; } } //野猪适配器对野猪进行适配 class WildPigAdapter implements Lion { private $o_wildPig;//野猪 public function __construct(WildPig $o_wildPig){ $this->o_wildPig = $o_wildPig; } public function roar():string { return $this->o_wildPig->eat(); } } //中国野猪 $o_chinaWildPig = new ChinaWildPig(); $o_wildPigAd = new WildPigAdapter($o_chinaWildPig); $o_hunter->hunt($o_wildPigAd); 结果为 uml类图 结论 作为结构化设计模式，适配器模式是在类已经存在的情况下，想要对其进行复用，但是由于接口不兼容而需要进行创建一个wrap，也就是创建一个壳(适配器)进行适配使其兼容现在接口,也就是说已存在才进行适配，如果不存而刻意进行适配，适得其反。例如上例中本类就不存在野猪接口，则不需要适配器]]></content>
      <categories>
        <category>design_pattern</category>
      </categories>
      <tags>
        <tag>design_pattern</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[git利用rebase对多个commit进行压缩]]></title>
    <url>%2F2018%2F01%2F24%2Fgit%20rebase%2F</url>
    <content type="text"><![CDATA[平常当进行commit的时候，可能对同一个问题进行了多次连续的commit,于是查看提交日志的时候出现一下情况 此时就存在许多冗余的commit日志，单个任务的commit日志过于碎片化，不利于版本控制 利用rebase对冗余commit进行压缩 git rebase -i commit_hash -i interactive 交互 commit_hash commit哈希值 如上图，我需要将commit665ca79到HEAD指针(44c13f5)压缩为一个commit git rebase -i 665ca79,进入vi交互界面 删除pick 44c13f5 update loading外的其它pick commit_hash commit_msg 修改pick 44c13f5 update loading为squash 44c13f5 update loading 保存退出,进入提交说明交互界面，修改新的提交说明,保存退出 如果成功，如下图，提交日志会变为如下 如果失败，如出现冲突，可先解决冲突，然后执行命令git add * &amp;&amp; git rebase –continue 取消rebase,git rebase –abort 分支rebase 如上图图1中，在commit B创建了一个新分支branch1,在此之后master分支提交了两次，C、E，branch1分支提交了两次D、F 切换branch1分支，执行命令git rebase master，git会基于与master共同祖先也就B，开始对比差异，并且以master为基分支，将B后branch1所有提交压缩到一起作为一次提交于master E提交后，如图2 这样有一个好处是，当创建一个新分支branch1开发一些额外任务的时候,master分支也继续开发，当完成任务的时候branch1可能存在许多次提交。利用rebase master可以把branch1的所有与master基于共同提交点后(B)的提交压缩为一个，同时branch1分支看起来就像刚刚从master分支最新的HEAD(E)指针创建提交的，结构更加简洁]]></content>
      <categories>
        <category>git</category>
      </categories>
      <tags>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[利用canvas进行截图]]></title>
    <url>%2F2018%2F01%2F23%2Fcanvas%E2%95%9C%E2%95%AA%E2%95%90%E2%95%9D%2F</url>
    <content type="text"><![CDATA[以下为利用html5的canvas进行图片截取功能的所有概述总结 如果已经描绘了一些图形的轮廓但是没有进行stroke或者填充，即使擦除整个canvas，当下次进行描绘或填充的时候仍然会会对此次以往的所有未进行描绘或填充的图形进行操作所以当决定舍弃所有以前的图形，如果图形比较复杂，应该进行ctx.beginPath() canvas元素本身不支持按键事件，可以通过以下方式 &lt;canvas id="canvas" width="800" height="600" tabindex="0">&lt;/canvas>]]></content>
      <categories>
        <category>canvas</category>
      </categories>
      <tags>
        <tag>canvas</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[canvas 绘制操作图像的方法]]></title>
    <url>%2F2018%2F01%2F22%2Fcanvas%E2%96%93%E2%94%98%E2%95%AB%E2%89%88%E2%95%90%E2%95%9D%E2%95%A7%C2%B1%E2%95%96%E2%95%9C%E2%95%96%C2%BF%2F</url>
    <content type="text"><![CDATA[1.canvas提供四个绘制操作图像的方法 drawImage() getImageData() putImageData() createImageData() 2.用法 ImageData getImageData(sx,sy,sw,sh) 该对象表示由以（sx，sy）开始且具有sw宽度和sh高度的矩形表示的画布区域的底层像素数据 ctx .putImageData（imagedata，dx，dy)ctx .putImageData（imagedata，dx，dy，dirtyX，dirtyY，dirtyWidth，dirtyHeight） putImageData()Canvas 2D API 的方法将来自给定ImageData对象的数据绘制到位图上。如果提供了一个脏矩形，则只会绘制该矩形的像素。此方法不受画布转换矩阵的影响。 参数 imagedata一个ImageData包含的像素值的阵列对象。 dx,dyimagedata放在目标图像的坐标 dirtyX,dirtyYimagedata需要放在目标图像的起点图像坐标 dirtyWidth,dirtyHeightimagedata需要放在目标图像的宽高 代码 //将整个imagedata放在目标图像以0,0为起点坐标上 this.ctx.putImageData(imagedata, 0, 0); //将imagedata放在目标图像以0,0为起点的坐标上，并且只绘制以sx,sy开始宽高为width和height的部分图像 this.ctx.putImageData(imagedata, 0, 0, sX, sY, width, height ); drawImage(image, dx, dy)drawImage(image, dx, dy, dw, dh)drawImage(image, sx, sy, sw, sh, dx, dy, dw, dh) 将一副图像绘制在canvas中，绘制图像为源图像，s开头，绘制的地方为目标图像d开头 参数 image image可以是HTMLImageElement类型的图像型，HTMLCanvasElement类型的canvas对象，或者HTMLVideoELement的视频对象 dx,dy 目标图像的x,y坐标 dw,dh需要绘制到目标图像的宽高，默认整个目标图像的宽高，第一类用法 sx,sy需要绘制源图像的x,y坐标 sw,sh 需要绘制的源图像的宽高,会根据目标图像的宽高进行缩放 ImageData createImageData(width,height) ImageData createImageData(imagedata) 创建一个新的空白的，指定宽高的ImageData对象，对象内的像素为透明的黑色,如果参数为imageData，那么创建的对象宽高与此imageData宽高相同]]></content>
      <categories>
        <category>canvas</category>
      </categories>
      <tags>
        <tag>canvas</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[原型设计模式]]></title>
    <url>%2F2018%2F01%2F19%2F%E2%95%98%C2%A1%E2%95%A8%E2%95%90%E2%94%80%C3%BA%E2%95%A9%E2%95%9C%2F</url>
    <content type="text"><![CDATA[原型设计模式是产生一个新对象通过clone的方式而不是进行newUML类图 如图，一共有两个类，人和爱好,人类属性中包含一个爱好对象，用来描述生成对象的各种爱好 当需要生产多个同类对象时可以通过clone的方式而不是new这样可以减少创建新对象过程中的资源消耗 人对象中的爱好属性同为一个对象，对象的传递方式为传引用，克隆原对象后，新对象的爱好属性与原对象的爱好属性指向相同，即为浅复制 如何进行深复制？即原对象中为对象的属性在进行复制时候，也会创建新对象而不是传递引用 深度复制以php为例 //人 class Person { public $Hobby; public $arr; public $age = 25; public function __construct(Hobby $Hobby,array $arr){ $this->Hobby = $Hobby; $this->arr = $arr; } public function __clone(){ $this->Hobby = clone $this->Hobby; } } //爱好 class Hobby { public $sport; //运动 public $song; //歌曲 public $food; //食物 public $game; //游戏 public function setSport(string $sport) :Hobby{ $this->sport = $sport; return $this; } public function setSong(string $song) :Hobby{ $this->song = $song; return $this; } public function setFood(string $food) :Hobby{ $this->food = $food; return $this; } public function setGame(string $game) :Hobby{ $this->game = $game; return $this; } } //======深复制 //爱好对象 $o_hobby = new Hobby(); $o_hobby = $o_hobby ->setSport("basketball") ->setSong("we are the world") ->setFood("beef") ->setGame("lol"); $a_arr = [ 'name' => 'lance', 'sex' => 'male' ]; $o_person = new Person($o_hobby, $a_arr); $o_clone = clone $o_person; 以上为利用php进行深复制，更多php clone的信息查看php clone中浅复制与深复制]]></content>
      <categories>
        <category>design_pattern</category>
      </categories>
      <tags>
        <tag>design_pattern</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[php clone中浅复制与深复制]]></title>
    <url>%2F2018%2F01%2F19%2Fphp%E2%95%9F%E2%94%82%E2%95%95%E2%94%A4%E2%95%93%E2%95%9E%E2%95%99%CE%B4%E2%95%94%CE%B5%E2%95%95%E2%94%A4%E2%95%93%E2%95%9E%2F</url>
    <content type="text"><![CDATA[php中对象的传递方式为传引用的方式，通过赋值的方式只能创建同一对象的多个而引用，要创建新的对象需进行clone 如果对象属性存在对另一个对象的引用，clone该对象只能进行浅复制，即该对象的属性中为对象的属性指向不变 要深复制，需要手动对属性中为对象的属性进行clone操作，即需要额外对魔术方法__clone进行操作 浅复制 //人 class Person { public $Hobby; public $arr; public $age = 25; public function __construct(Hobby $Hobby,array $arr){ $this->Hobby = $Hobby; $this->arr = $arr; } } //爱好 class Hobby { public $sport; //运动 public $song; //歌曲 public $food; //食物 public $game; //游戏 public function setSport(string $sport) :Hobby{ $this->sport = $sport; return $this; } public function setSong(string $song) :Hobby{ $this->song = $song; return $this; } public function setFood(string $food) :Hobby{ $this->food = $food; return $this; } public function setGame(string $game) :Hobby{ $this->game = $game; return $this; } } //==========克隆对象并改变克隆对象属性观察原对象属性变化 //爱好对象 $o_hobby = new Hobby(); $o_hobby = $o_hobby ->setSport("basketball") ->setSong("we are the world") ->setFood("beef") ->setGame("lol"); $a_arr = [ 'name' => 'lance', 'sex' => 'male' ]; $o_person = new Person($o_hobby, $a_arr); $o_clone = clone $o_person; //===========打印结果 //原对象 echo "原对象属性&lt;br/>"; echo "&lt;pre>"; print_r($o_person); echo "&lt;/pre>"; //改变克隆对象属性 $o_clone->Hobby->setFood("noodle"); $o_clone->arr['name'] = "jianglong"; $o_clone->age = 30; //改变后的clone对象 echo "改变后的clone对象&lt;br/>"; echo "&lt;pre>"; print_r($o_clone); echo "&lt;/pre>"; //原对象 echo "改变clone对象后，原对象属性&lt;br/>"; echo "&lt;pre>"; print_r($o_person); echo "&lt;/pre>"; 有两个类，一个是人，一个是爱好，人拥有三个属性，一个对爱好对象的引用，一个数组，一个年龄。爱好是对人对某些方面爱好的设定 生成爱好对象，并设置各类爱好 实例化人对象，并设置人的爱好对象，以及包含额外信息数组 克隆人对象，并对克隆人对象的爱好，数组，以及年龄分别进行改变 分别打印，原始对象，改变克隆属性后的克隆对象，原始对象 结果如下: 原对象属性 //Person Object ( [Hobby] => Hobby Object ( [sport] => basketball [song] => we are the world [food] => beef [game] => lol ) [arr] => Array ( [name] => lance [sex] => male ) [age] => 25 ) //改变后的clone对象 Person Object ( [Hobby] => Hobby Object ( [sport] => basketball [song] => we are the world [food] => noodle [game] => lol ) [arr] => Array ( [name] => jianglong [sex] => male ) [age] => 30 ) //改变clone对象后，原对象属性 Person Object ( [Hobby] => Hobby Object ( [sport] => basketball [song] => we are the world [food] => noodle [game] => lol ) [arr] => Array ( [name] => lance [sex] => male ) [age] => 25 ) 结果为对克隆对象的普通属性即年龄，对象属性爱好Hobby，额外属性数组进行改变后，原对象只有对象属性发生了变化可以看出: clone时，只有对象是浅复制，即传递引用的方式,克隆对象的属性对象与原对象的属性对象都指向同一个地址，无论克隆对象还是原对象对应属性发生变化，二者的属性对象都会受到影响 深复制 深复制只需要在Person类中在魔术方法__clone中再次对对象属性进行一次clone //人 class Person { public $Hobby; public $arr; public $age = 25; public function __construct(Hobby $Hobby,array $arr){ $this->Hobby = $Hobby; $this->arr = $arr; } public function __clone(){ $this->Hobby = clone $this->Hobby; } } 执行的操作与赋值相同，结果如下: //原对象属性 Person Object ( [Hobby] => Hobby Object ( [sport] => basketball [song] => we are the world [food] => beef [game] => lol ) [arr] => Array ( [name] => lance [sex] => male ) [age] => 25 ) //改变后的clone对象 Person Object ( [Hobby] => Hobby Object ( [sport] => basketball [song] => we are the world [food] => noodle [game] => lol ) [arr] => Array ( [name] => jianglong [sex] => male ) [age] => 30 ) //改变clone对象后，原对象属性 Person Object ( [Hobby] => Hobby Object ( [sport] => basketball [song] => we are the world [food] => beef [game] => lol ) [arr] => Array ( [name] => lance [sex] => male ) [age] => 25 ) 结果为原对象的属性对象Hobby并未发生变化，说明此次复制原对象的属性对象不再是引用的方式，而是clone一个新的对象 clone的方式不需要重新再次实例化对象，减少了资源消耗,当对象的属性也是一个对象时需要注意浅度复制和利用魔术方法__clone进行深度复制设计模式中原型模式即利用clone的方式]]></content>
      <categories>
        <category>php</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[工厂方法与抽象工厂模式]]></title>
    <url>%2F2018%2F01%2F18%2F%E2%95%A3%C3%B1%E2%94%82%C2%BA%E2%95%96%E2%95%9C%E2%95%96%C2%BF%E2%95%99%CE%B4%E2%94%82%CE%98%E2%95%A7%E2%89%A4%E2%95%A3%C3%B1%E2%94%82%C2%BA%E2%94%80%C3%BA%E2%95%A9%E2%95%9C%2F</url>
    <content type="text"><![CDATA[工厂方法uml类图 工厂方法的工厂是用来生成对象,如UML图,该工厂生成水果对象,每个子类工厂分别生产香蕉,橘子,和苹果对象 与简单工厂比,工厂方法将生成对象的过程延迟到子类,这样在有新类型对象加入的时候,可以增加新的工厂子类,而不是修改原方法,符合开放封闭原则 抽象工厂模式uml类图 抽象工厂模式是用来生成一些列相关对象的集合,如UML图,每个子类工厂同时实现两个方法,分别生产水果和饮料对象 水果和饮料有不同分类，水果可以生成饮料，两者相互有联系，通过这种方式既集成对象的封装，又增强了对象交互]]></content>
      <categories>
        <category>design_pattern</category>
      </categories>
      <tags>
        <tag>design_pattern</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[建造者模式]]></title>
    <url>%2F2018%2F01%2F18%2F%E2%95%9C%C2%BF%E2%95%98%E2%88%9E%E2%95%92%E2%96%80%E2%94%80%C3%BA%E2%95%A9%E2%95%9C%2F</url>
    <content type="text"><![CDATA[建造者模式将一个复杂对象的建造过程与表现分离，使同样的建造过程可以建造不同表示UML类图 例如: 当建造一个产品(人偶)，这个过程包括构建头、手、身体、脚,过程固定，但高矮胖瘦在构建的过程中表现不同，这些为构建表现细节，过程是抽象的，即细节依赖抽象 我们对建造模型各过程进行抽象，让子类实现具体的构建表现细节 需要一个指挥者来指挥构建过程 代码实例: //构建产品 class Product { public $A; public $B; public $C; public function addA($something) { $this->A = $something; } public function addB($something) { $this->B = $something; } public function addC($something) { $this->C = $something; } } //建造过程 abstract class Builder { public $Product; public function __construct(Product $product){ $this->Product = $product; } abstract function createPartA();//建造过程A abstract function createPartB();//过程B abstract function createPartC();//过程C public function getProduct() {//获取建造对象 return $this->Product; } } //具体构建者 class Builder1 extends Builder { function createPartA() { $this->Product->addA('我创建了A1'); } function createPartB() { $this->Product->addB('我创建了B1); } function createPartC() { $this->Product->addC('我创建了C1'); } } //具体构建者 class Builder2 extends Builder { function createPartA('我创建了A2') { $this->Product->addA(); } function createPartB() { $this->Product->addB('我创建了B2'); } function createPartC('我创建了C2’) { $this->Product->addC(); } } //构建过程指挥家 class Composer { private $Builder; //传入构建对象 public function __construct(Builder $builder) { $this->Builder = $builder; } //构建过程 public function startBuilder() { $this->Builder->createPartA(); $this->Builder->createPartB(); $this->Builder->createPartC(); } } //调用过程 $o_builder = new Builder1(new Product()); $o_composer = new Composer($o_builder); //开始构造 $o_composer->startBuilder(); //返回构造对象 $o_builder->getProduct();]]></content>
      <categories>
        <category>design_pattern</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[canvas2d坐标系变换]]></title>
    <url>%2F2018%2F01%2F18%2Fcanvas2d%E2%95%AB%C2%B0%E2%96%92%CE%A9%E2%95%A7%E2%95%A1%E2%96%92%CE%A3%E2%95%97%E2%95%97%2F</url>
    <content type="text"><![CDATA[canvas 2d坐标系有三类变换,平移,缩放,旋转。尽管三类变换提供了三个不同的函数分别进行处理,但也提供了额外简单的函数对所有变换一起处理 transform 与 setTransform这两个函数参数是一致的,绘制坐标系的方式不同 transform 函数对当前坐标系的基础上进行变换 setTransform 对单位矩阵进行变换 参数transform(a,b,c,d,e,f) x1 = ax + cy + e; y1 = bx + dy + f; 坐标系平移:(1,0,0,1,50,50) x1 = x + 50; y1 = y + 50; 坐标系原点 x轴和y轴都平移50个像素 坐标系缩放:(2,0,0,2,0,0) x1 = 2x; y1 = 2y; 坐标系x,y同时放大两倍 坐标系旋转:(Math.cos(50 Math.PI / 180),Math.sin(50 Math.PI / 180), - Math.sin(50 Math.PI / 180),Math.cos(50 Math.PI / 180),0,0) x1 = Math.cos(50 Math.PI / 180) x - Math.sin(50 Math.PI / 180) y + e; y1 = Math.sin(50 Math.PI / 180) x + Math.cos(50 Math.PI / 180) y + f; 坐标系旋转50度]]></content>
      <categories>
        <category>canvas</category>
      </categories>
      <tags>
        <tag>canvas</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[canvas图像合成]]></title>
    <url>%2F2018%2F01%2F17%2Fcanvas%E2%95%90%E2%95%9D%E2%95%A7%C2%B1%E2%95%91%E2%95%A7%E2%94%82%E2%95%94%2F</url>
    <content type="text"><![CDATA[canvas图像合成能绘制很棒的效果.先介绍图像合成过程,最后会给出一个利用图像合成制作聚光灯效果图像合成 globalCompositeOperation属性 以下红色为目标图像(已经绘制),蓝色为源图1.ctx.globalCompositeOperation = \”source-atop\”,仅绘制源图像在目标图像上的部分,其他忽略 2.ctx.globalCompositeOperation = \”source-out\”,整个图像仅保留绘制源图像在目标图像外的部分 3.ctx.globalCompositeOperation = \”source-in\”,整个图像仅保留绘制源图像在目标图像上的部分 4.ctx.globalCompositeOperation = \”source-over\”,源图像绘制在目标图像之上覆盖,默认合成方式 5.ctx.globalCompositeOperation = \”destination-atop\”,与source-atop相反,保留源图像,目标图像保留与源图像重叠部分,并置顶 j 6.ctx.globalCompositeOperation = \”destination-out\”,与source-out,整个图像保留目标图像,目标图像与源图像重叠部分擦除 7.ctx.globalCompositeOperation = \”destination-in\”,与source-in,整个图像仅保留目标图像在源图像上的部分 8.ctx.globalCompositeOperation = \”destination-over\”,与source-over相反 9.ctx.globalCompositeOperation = \”lighter\”,源图像与目标图像重叠处进行颜色加色处理 10.ctx.globalCompositeOperation = \”copy\”,源图像被保留其他部分擦除 11.ctx.globalCompositeOperation = \”xor\”,源图像与目标图像重叠处进行擦除 利用图像destination-atop制作聚光灯效果过程:首先将一张图片作为canvas容器的背景图片,然后在整张画布上画一层遮蔽色(目标图像),如黑色.然后当鼠标移动到画布上,以鼠标为中心画一定大小的圆形图像(源图像)进行图像合成 let img = new Image();//遮蔽色(在此为一张图片) let t = $("#hidePicture");//画布 img.src = "/static/img/canvas_bg.jpg"; img.onload = function () {//加载完图片 let ctx = t[0].getContext("2d"), canvas = ctx.canvas; t.css({//设置canvas背景图片 "background": "url(/static/img/zard.jpg)",//canvas背景图片 "background-position":"-80px -100px ", "background-repeat":"no-repeat", "width":$(".col-sm-3").width() }); ctx.rect(0, 0, canvas.width, canvas.height); let pattern = ctx.createPattern(img, "repeat"); ctx.fillStyle = pattern; ctx.fill(); let Light = function (ctx, r) { this.ctx = ctx; this.canvas = this.ctx.canvas; this.oldImage = this.ctx.getImageData(0, 0, this.canvas.width, this.canvas.height); this.r = r; this.x = 0; this.y = 0; //聚光灯 this.light = function () { //线性渐变 this.ctx.save(); this.ctx.beginPath(); this.ctx.globalCompositeOperation = "destination-out";//图像合成方式 let ra = this.ctx.createRadialGradient(this.x, this.y, 0, this.x, this.y, this.r); ra.addColorStop(0, 'rgba(255,255,255,1'); ra.addColorStop(0.7, 'rgba(255,255,255,1'); ra.addColorStop(1, 'rgba(255,255,255,0'); this.ctx.arc(this.x, this.y, this.r, 0, Math.PI * 2); this.ctx.fillStyle = ra; this.ctx.fill(); this.ctx.restore(); }; this.init = function () { let self = this; //鼠标移入,进行图像合成 this.canvas.onmousemove = function (e) { e.preventDefault(); self.ctx.clearRect(0, 0, self.canvas.width, self.canvas.height); self.ctx.putImageData(self.oldImage, 0, 0); self.x = e.clientX - $(self.canvas).offset().left; self.y = e.clientY - $(self.canvas).offset().top + $(document).scrollTop(); self.light(); }; //鼠标移除清除画布,添加遮盖色 this.canvas.onmouseout = function (e) { e.preventDefault(); self.ctx.clearRect(0, 0, self.canvas.width, self.canvas.height); ctx.rect(0, 0, canvas.width, canvas.height); ctx.fillStyle = pattern; ctx.fill(); } } }; let light = new Light(ctx, 100); light.init(); }]]></content>
      <categories>
        <category>canvas</category>
      </categories>
      <tags>
        <tag>canvas</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[js格式化手机号码格式]]></title>
    <url>%2F2018%2F01%2F16%2Fjs%E2%95%95%C2%B1%E2%95%A9%E2%95%9C%E2%95%97%C2%BB%E2%95%A9%E2%95%93%E2%95%97%C2%B7%E2%95%91%E2%94%BC%E2%94%AC%CE%B4%E2%95%95%C2%B1%E2%95%A9%E2%95%9C%2F</url>
    <content type="text"><![CDATA[var format_phone = function (number){ var no_space = number.replace(/\s/g,''), length = no_space.length, sep = ' ';//分割符号 if(length &lt;= 3){ return no_space; }else if(length > 3 &amp;&amp; length &lt;= 7){ return no_space.substr(0,3) + sep + no_space.substr(3); }else { return no_space.substr(0,3) + sep + no_space.substr(3, 4) + sep + no_space.substr(7); } };]]></content>
      <categories>
        <category>javascript</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[利用取地址操作符，对数组子元素进行归类]]></title>
    <url>%2F2018%2F01%2F16%2F%E2%94%94%E2%88%9A%E2%95%99%E2%94%9C%E2%95%A1%E2%95%AA%E2%95%93%E2%95%96%E2%96%93%E2%94%98%E2%95%AB%E2%89%88%E2%95%96%E2%88%9A%E2%95%A2%E2%95%98%E2%95%A9%C2%B2%E2%95%AB%CE%98%E2%95%AB%E2%95%99%E2%95%98%C2%AC%E2%95%A6%E2%95%AA%E2%95%9C%C2%B0%E2%95%A8%E2%95%A8%E2%95%A3%CE%98%E2%94%94%CE%B1%2F</url>
    <content type="text"><![CDATA[$a_data = [ 1 => [ 'id' => 1, 'pid' => 0, 'data' => [] ], 2 => [ 'id' => 2, 'pid' => 1, 'data' => [] ], ]; $a_newData = []; foreach($a_data as $key => $v): if($v['pid'] !== 0): $a_data[$v['pid']['sub']][] = &amp;$a_data[$key]; else: $a_newData[] = &amp;$a_data[$key]; endif; endforeach;]]></content>
      <categories>
        <category>php</category>
      </categories>
      <tags>
        <tag>php pointer</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[js图片上传预览]]></title>
    <url>%2F2018%2F01%2F16%2Fjs%E2%95%90%E2%95%9D%E2%95%9E%C2%BC%E2%95%94%E2%95%A7%E2%94%A4%C2%BD%E2%95%98%C3%B1%E2%94%94%E2%94%94%2F</url>
    <content type="text"><![CDATA[define(['jquery'], function ($) { return function () { //图片上传预览 this.imgPreview = function (fileDom, previewBox) { if (window.FileReader) { var reader = new FileReader(); } else { alert("您的设备不支持图片预览功能，如需该功能请升级您的设备！"); } //获取文件 var file = fileDom[0].files[0]; var imageType = /^image\//; //是否是图片 if (!imageType.test(file.type)) { alert("请选择图片！"); return; } //读取完成 reader.onload = function (e) { //获取图片dom var img = previewBox[0]; //图片路径设置为读取的图片 img.src = e.target.result; }; reader.readAsDataURL(file); }; //多图上传预览 this.mulImgPreview = function (fileDom, preview) { //图片地址容器 var imagesUrl = []; //清空预览容器 preview.html(''); var files = fileDom[0].files, objUrl; for (var i = 0; i &lt; files.length; i++) { objUrl = this.getObjectURL(files[i]); if (objUrl) { imagesUrl.push(objUrl); } } //将图片放置在容器中 for (var j = 0; j &lt; imagesUrl.length; j++) { preview.append($("&lt;img/>").attr('src', imagesUrl[j]).attr({width:200,height:200})).append('&amp;nbsp;'); } }; this.getObjectURL = function (file) { //建立一個可存取到該file的url var url = null; if (window.createObjectURL != undefined) { // basic url = window.createObjectURL(file); } else if (window.URL != undefined) { // mozilla(firefox) url = window.URL.createObjectURL(file); } else if (window.webkitURL != undefined) { // webkit or chrome url = window.webkitURL.createObjectURL(file); } return url; } }; });]]></content>
      <categories>
        <category>javascript</category>
      </categories>
      <tags>
        <tag>js</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[git tips]]></title>
    <url>%2F2018%2F01%2F16%2Fgit%20tips%2F</url>
    <content type="text"><![CDATA[1.删除分支 本地: git branch -d branch_name 远程: git branch -r -d origin/branch_name &amp;&amp; git push origin(此处有个空格) :branch_name2.推送分支 git push origin local_branch_name:remote_branch_name 3.删除标签 本地: git tag -d tag_name 远程: git push origin :refs/tags/tag_name 4444.暂存 保存未提交的数据: git stash save message 查看暂存: git stash list 从栈中恢复，并从栈中删除: git stash pop index 从栈中回复，不从栈中删除：git stash apply index]]></content>
      <categories>
        <category>git</category>
      </categories>
      <tags>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[复制内容到剪切板]]></title>
    <url>%2F2018%2F01%2F16%2Fjs%E2%95%95%E2%94%A4%E2%95%93%E2%95%9E%E2%94%80%E2%94%8C%E2%95%9A%E2%96%8C%E2%95%A1%E2%95%9C%E2%95%9D%E2%8C%A0%E2%95%9F%E2%95%A8%E2%96%91%CF%83%2F</url>
    <content type="text"><![CDATA[var content="我是内容"; var temp = $("&lt;input type='text' value='" + content + "'/>"); temp.appendTo('body'); temp.select(); if(document.execCommand('copy')){ layer.msg('media_id已复制到剪切板！'); }else{ layer.msg('复制到剪切板失败！'); } temp.remove();]]></content>
      <categories>
        <category>javascript</category>
      </categories>
      <tags>
        <tag>js</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[设计模式6大基本原则]]></title>
    <url>%2F2018%2F01%2F13%2F%E2%95%94%CE%A6%E2%95%9D%E2%95%9E%E2%94%80%C3%BA%E2%95%A9%E2%95%9C%E2%95%98%C2%A1%E2%95%98%E2%89%A5%2F</url>
    <content type="text"><![CDATA[单一职责原则 应该有且只有一个原因引起类的变更 开放封闭原则 程序对扩展是开放的，对更改是封闭的。 依赖倒转原则 高层模块不依赖低层模块，两者都依赖抽象。抽象不依赖细节，细节依赖抽象。 里氏代换原则 子类型必须能替换掉他们的父类型。 接口隔离原则 类间的依赖关系应该建立在最小的接口上 迪比特法则 一个类对自己依赖的类知道的越少越好,或一个类只与直接类通信(属性，方法参数，方法返回中存在的类对象，其他为间接)]]></content>
      <categories>
        <category>design_pattern</category>
      </categories>
      <tags>
        <tag>design_pattern</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[nginx配置伪静态]]></title>
    <url>%2F2018%2F01%2F11%2Fnginx%E2%94%BC%CE%A3%E2%95%93%E2%94%9C%E2%95%AC%E2%96%92%E2%95%9B%E2%96%93%E2%95%A0%C2%BC%2F</url>
    <content type="text"><![CDATA[nginx-fastcgi转载自[https://segmentfault.com/a/1190000002667095] nginx变量转载自[http://www.nginx.cn/273.html] ci框架配置转载自[https://www.miaoyueyue.com/archives/95.html] 正则表达式转载自[https://baike.baidu.com/item/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/1700215?fr=aladdin] location转载自[http://seanlook.com/2015/05/17/nginx-location-rewrite] try_files转载自[https://www.hi-linux.com/posts/53878.html]]]></content>
      <categories>
        <category>nginx</category>
      </categories>
      <tags>
        <tag>nginx</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[php错误类型]]></title>
    <url>%2F2018%2F01%2F03%2Fphp%E2%94%A4%CF%86%E2%95%AC%E2%89%A4%E2%94%94%CE%B1%E2%95%A8%E2%95%90%2F</url>
    <content type="text"><![CDATA[对PHP的错误类型一直很模糊，在此进行总结。常见的错误类型 E_DEPRECATED E_NOTICE E_WARNING E_ERROR E_PARSE E_DEPRECATED 反对A run-time notice indicating that the code will not work in future versions of PHP 情形: mysql函数库在7.0版本移除E_NOTICE 提示错误A run-time notice indicating that the script encountered something that could possibly an error, although the situation could also occur when running a script normally。情形: 使用未定义的变量E_WARNING 警告A run-time warning. It is non-fatal and most errors tend to fall into this category. The execution of the script is not stopped.情形: include 不存在的文件E_ERROR 致命错误A fatal run-time error, that can’t be recovered from. The execution of the script is stopped immediately.情形: require一个不存在的文件 使用一个未定义的函数、类、接口E_PARSE 解析错误The compile-time parse error. Parse errors should only be generated by the parser.情形: 语法错误 捕获错误类型 set_error_handler(callback[,$error_type=E_ALL|E_STRICT)The following error types cannot be handled with a user defined function: E_ERROR, E_PARSE, E_CORE_ERROR, E_CORE_WARNING, E_COMPILE_ERROR, E_COMPILE_WARNING, and most of E_STRICT raised in the file where set_error_handler() is called 当用户自定了捕获异常函数，程序会绕过PHP 标准错误处理程序,除非在回调函数中返回false,error_reporting()函数也会被忽略。 set_error_handler(function($errno,$errstr){ echo "错误码".$errno; echo "错误信息".$errstr; //return false; }); echo $a;//发出一个notice 注册一个脚本结束时或者程序发生一个fatal error执行的函数 void register_shutdown_function ( callable $callback [, mixed $parameter [, mixed $… ]] )可以注册多个回调函数，函数将会被依次调用 function fatal_error(){ $error = error_get_last(); if($error){ //dosomethin $errno = $error["type"]; $errfile = $error["file"]; $errline = $error["line"]; $errstr = $error["message"]; } } register_shutdown_function("fatal_error"); PHP7中一些fatal error也能被捕获例如:用了一个未定义的函数 try{ undefinded(); }catch(Error $e){ echo $e->getMessage(); } //Call to undefined function undefinded()]]></content>
      <categories>
        <category>php</category>
      </categories>
      <tags>
        <tag>php</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[yield 和yield from]]></title>
    <url>%2F2018%2F01%2F02%2Fphp%20yield%2F</url>
    <content type="text"><![CDATA[yield中文为生产,是作为php的生成器提供了一种更容易的方法来实现简单的对象迭代，相比较定义类实现 Iterator 接口的方式，性能开销和复杂性大大降低 1.yield 简单使用 //方式一 该函数功能迭代10次的时间戳保存到数组中 function getTime(){ for($i = 1; $i &lt;= 10; $i ++){ $time[] = time(); } return $time; }; $time = getTime(); $test = function() use ($time){ foreach($time as $value){ echo $value."&lt;br/>"; sleep(1); } }; $test(); /*结果: 1514886015 1514886015 1514886015 1514886015 1514886015 1514886015 1514886015 1514886015 1514886015 1514886015*/ //方式二(yield) function getTime(){ for($i = 1; $i &lt;= 10; $i ++){ yield time(); } }; $time = getTime(); $test = function() use ($time){ foreach($time as $value){ echo $value."&lt;br/>"; sleep(1); } }; $test(); /*结果 1514944609 1514944610 1514944611 1514944612 1514944613*/ /* *方式一函数getTime迭代数量只有十次速度很快迭代完，所有时间戳都相同，尽管sleep但是已经一次性迭代完成了，时间戳都相同。 *方式二函数getTime生成一个generator对象。在每次时间戳依次递增1，这仿佛好像是执行迭代的操作入队列，但不进行真正的操作，当对generaotr对象进行遍历的时候依次出队进行操作，获取的是此时的时间戳。 */ 2.yield from PHP7中，通过生成器委托（yield from），可以将其他生成器、可迭代的对象、数组委托给外层生成器。外层的生成器会先顺序 yield 委托出来的值，然后继续 yield 本身中定义的值。 function getNumber(){ for($i = 1; $i &lt;= 5; $i ++){ yield $i; } }; function getNumber2(){ for($i = 6; $i &lt;= 10; $i ++){ yield $i; } } function getNumber3(){ yield from getNumber(); for($i = 6; $i &lt;= 10; $i ++){ yield $i; } } function getNumber4(){ for($i = 6; $i &lt;= 10; $i ++){ yield $i; } yield from getNumber(); } echo "一般生成器:"; foreach(getNumber2() as $value){ echo $value." "; } echo "&lt;br/>"; echo "委托给其他生成器:"; foreach(getNumber3() as $value){ echo $value." "; } echo "&lt;br/>"; echo "委托给其他生成器:"; foreach(getNumber4() as $value){ echo $value." "; } /* *一般生成器:6 7 8 9 10 * 委托给其他生成器:1 2 3 4 5 6 7 8 9 10 * 委托给其他生成器:6 7 8 9 10 1 2 3 4 5 */ 3.yield 与返回值 如果生成器被迭代完成，或者运行到 return 关键字，是会给这个生成器返回值的 function yieldReturn() { for($i=1;$i&lt;=5;$i++){ yield $i; } return "生成器迭代完成了"; } foreach($obj = yieldReturn() as $value){ echo $value."&lt;br/>"; } echo $obj->getReturn(); /*结果 * 1 * 2 * 3 * 4 * 5 * 生成器迭代完成了 */]]></content>
      <categories>
        <category>php</category>
      </categories>
      <tags>
        <tag>php</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[canvas渐变]]></title>
    <url>%2F2017%2F12%2F10%2Fcanvas%E2%95%9C%C3%91%E2%96%92%CE%A3%2F</url>
    <content type="text"><![CDATA[canvas渐变学习2017年12月10日 by jianglong1992 线性渐变linearGradient 放射性渐变县会用重点颜色填充画布以外的其他区域 var context = canvas.getContext('2d'); //占据画布的一条垂直渐变线,0,canvas.height 代表一条垂线 linearGradient = context.createLinearGradient(0,0,0,canvas.height); lineGradient.addColorStop(0, 'blue'); lineGradient.addColorStop(0.25, 'white'); lineGradient.addColorStop(0.5, 'purple'); lineGradient.addColorStop(0.75, 'red'); lineGradient.addColorStop(1, 'yellow'); context.fillStyle = lineGradient; context.rect(0, 0, canvas.width, canvas.height); context.fill(); //水平渐变线 linearGradient = context.createLinearGradient(0,0,canvas.width,0); 同上 放射性渐变线radiaGradient 放射性渐变线不会填充以外的空白区域 var context = canvas.getContext('2d'); var radialGradient = context.createRadialGradient( canvas.width/3,canvas.height,10, canvas.width/2,0,90 ); radialGradient.addColorStop(0, 'blue'); radialGradient.addColorStop(0.25, 'white'); radialGradient.addColorStop(0.5, 'purple'); radialGradient.addColorStop(0.75, 'red'); radialGradient.addColorStop(1, 'yellow'); context.fillStyle = radialGradient; context.rect(0, 0, canvas.width, canvas.height); context.fill();]]></content>
      <categories>
        <category>canvas</category>
      </categories>
      <tags>
        <tag>canvas</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[linux sed使用]]></title>
    <url>%2F2017%2F12%2F06%2Flinux%20sed%E2%95%A9%E2%95%A3%E2%95%99%E2%94%9C%2F</url>
    <content type="text"><![CDATA[文本替换程序——流替换工具sed(stream editor)1. 替换第一个、所有、第N个 text="wo shi zhangsan zhangsan zhangsan" #1.默认替换第一个 s/regular/replace echo $text | sed 's/zhangsan/lisi/' #wo shi lisi zhangsan zhangsan #2.替换所有 g s/regular/replace/g echo $text | sed 's/zhangsan/lisi/g' #wo shi lisi lisi lisi #3.替换某一个n s/regular/repalce/n echo $text | sed 's/zhangsan/lisi/2' #wo shi zhangsan lisi zhangsan 2.打印，替换指定行-n p text=&quot;wo shi zhangsan lisi\r wo shi zhangsan lance\r wo shi lisi lance\r wo shi zhangsan lisi wangwu&quot; 1.打印含有zhangsan的行 2.打印含有zhangsan或lisi的行 3.打印指定行 4.替换某存在某个表达式，或不存在某个表达式的行 5.替换某几行 6.替换符合要求的几行(存在张三或李四) 7.多个正则选项命令e sed -e option1 -e option file 8.执行正则选项文件 sed -f optionfile file optionfile option1 option2 … 9.使用标准输入-,用于测试特别有用 sed option -]]></content>
      <categories>
        <category>shell</category>
      </categories>
      <tags>
        <tag>shell</tag>
      </tags>
  </entry>
</search>
